<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:39 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>match_sph.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="match_sph.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    MATCH_SPH</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    For each angular point in one vector, determines the closest angular match</span>
<span class="comments">;    from another vector. Method is to take the list returned by</span>
<span class="comments">;    MATCHALL_SPH and narrow it down to the closest match.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Astro</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    Result = MATCH_SPH(Ra1, Dec1, Ra2, Dec2, Sphrad)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    Ra1:     Vector of longitude coordinates, in degrees.</span>
<span class="comments">;</span>
<span class="comments">;    Dec1:    Vector of latitude coordinates, in degrees.</span>
<span class="comments">;</span>
<span class="comments">;    Ra2:     Vector of longitude coordinates, in degrees.</span>
<span class="comments">;</span>
<span class="comments">;    Dec2:    Vector of latitude coordinates, in degrees.</span>
<span class="comments">;</span>
<span class="comments">;    Sphrad:  Maximum angular distance, in degrees. Matches outside</span>
<span class="comments">;             of this radius are ignored.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;    MINDIST:  Optional output containing an array of the actual distance</span>
<span class="comments">;               to the closest match for each element of Ra1, Dec1.</span>
<span class="comments">;</span>
<span class="comments">;    ONE_TO_ONE:  Enforces one-to-one matching. By default, matching can</span>
<span class="comments">;                 be many-to-one, i.e. one entry in Ra2,Dec2 can be the</span>
<span class="comments">;                 closest match to several entries in Ra1,Dec1. If</span>
<span class="comments">;                 /ONE_TO_ONE is given, then each multiple entry in Ra2,Dec2</span>
<span class="comments">;                 is first assigned to its closest point in Ra1,Dec1. Then any</span>
<span class="comments">;                 entries in Ra1,Dec1 that have lost their match are assigned</span>
<span class="comments">;                 the next closest point within Sphrad. This process is</span>
<span class="comments">;                 iterated until all points in Ra1,Dec1 are matched to a</span>
<span class="comments">;                 unique point in Ra2,Dec2 or there are no more points</span>
<span class="comments">;                 within Sphrad</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;    The function returns an array with one entry for each Ra1, Dec1</span>
<span class="comments">;    element containing the index in Ra2, Dec2 that is closest, or -1 if</span>
<span class="comments">;    there are none within Sphrad.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;    n1 = 25</span>
<span class="comments">;    n2 = 10</span>
<span class="comments">;    seed = 43L</span>
<span class="comments">;    ra1 = randomn(seed, n1)</span>
<span class="comments">;    dec1 = randomn(seed, n1)</span>
<span class="comments">;    ra2 = randomn(seed, n2)</span>
<span class="comments">;    dec2 = randomn(seed, n2)</span>
<span class="comments">;    result1 = match_sph(ra1, dec1, ra2, dec2, 1.)</span>
<span class="comments">;    result2 = match_sph(ra1, dec1, ra2, dec2, 1., /one_to_one)</span>
<span class="comments">;    !p.multi=[0,2,1]</span>
<span class="comments">;    plot, psym=1, ra1, dec1, xrange=[-3,3], yrange=[-3,3], title='Default'</span>
<span class="comments">;    oplot, psym=4, ra2, dec2</span>
<span class="comments">;    for i=0l,n1-1 do if result1[i] ne -1 then oplot, [ra1[i],ra2[result1[i]]], $</span>
<span class="comments">;      [dec1[i],dec2[result1[i]]]</span>
<span class="comments">;    plot, psym=1, ra1, dec1, xrange=[-3,3], yrange=[-3,3], title='/ONE_TO_ONE'</span>
<span class="comments">;    oplot, psym=4, ra2, dec2</span>
<span class="comments">;    for i=0l,n1-1 do if result2[i] ne -1 then oplot, [ra1[i],ra2[result2[i]]], $</span>
<span class="comments">;      [dec1[i],dec2[result2[i]]]</span>
<span class="comments">;    </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;    Written by:    Jeremy Bailin</span>
<span class="comments">;    10 June 2008   Public release in JBIU as WITHINSPHRAD</span>
<span class="comments">;    24 April 2009  Vectorized as WITHINSPHRAD_VEC</span>
<span class="comments">;    25 April 2009  Polished to improve memory use</span>
<span class="comments">;    9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing</span>
<span class="comments">;                   heavily from JD Smith's MATCH_2D</span>
<span class="comments">;    13 May 2009    Removed * from LHS index in final remapping for speed</span>
<span class="comments">;    23 August 2010 Modified to only return closest match as WITHINSPHRAD_CLOSEST</span>
<span class="comments">;                   (importing some stuff back from MATCH_2D)</span>
<span class="comments">;    8 Sept 2010    Renamed MATCH_SPH. Added /ONE_TO_ONE option, and modified</span>
<span class="comments">;                   to explicitly call MATCHALL_SPH and then cull.</span>
<span class="comments">;    13 April 2011  Fixed to work around cumulative total 1-element array bug.</span>
<span class="comments">;-</span>
<a id="match_sph:source"></a>function match_sph, ra1, dec1, ra2, dec2, sphrad, mindist=mindist, $
  one_to_one=one2onep

if n_elements(ra2) ne n_elements(dec2) then $
  message, 'RA2 and DEC2 must have the same number of elements.'
if n_elements(ra1) ne n_elements(dec1) then $
  message, 'RA1 and DEC1 must have the same number of elements.'
if n_elements(sphrad) ne 1 then $
  message, 'SPHRAD must contain one element.'

n1 = n_elements(ra1)
n2 = n_elements(ra2)

<span class="comments">; get all matches within sphrad</span>
matches = matchall_sph(ra1, dec1, ra2, dec2, sphrad, nwithin, distance=distance)

<span class="comments">; if there are no matches, just quit</span>
if total(nwithin) eq 0 then return, replicate(-1L, n1)

<span class="comments">; sort all by distance</span>
<span class="comments">; create unique distance by adding the maximum distance times i1 to each</span>
<span class="comments">; entry corresponding to i1:</span>
<span class="comments">; first use histogram magic to create a list of which entry in 1 each</span>
<span class="comments">; match corresponds to</span>
<span class="comments">; note: using [] around cumulative total to deal with bug for 1-element arrays</span>
hchunk = histogram([total(nwithin,/cumul,/int)]-1, min=0, reverse_indices=chunkri)
index1 = chunkri[0:n_elements(hchunk)-1]-chunkri[0] + (nwithin[0] eq 0)
<span class="comments">; now create unique distance by adding max(distance) * index1:</span>
uniqdist = distance + 1.1*max(distance)*index1
<span class="comments">; and sort</span>
sortdist = sort(uniqdist)
distance = distance[sortdist]
matches[n1+1] = (matches[n1+1:*])[sortdist]

matchloc = matches[0:n1-1]   <span class="comments">; starting point for each entry in list 1</span>
nomatchp = nwithin eq 0      <span class="comments">; 1 for entries with no match in sphrad</span>

<span class="comments">; iterate checking for multiple matches</span>
nincrements = lonarr(n1)
repeat begin
  nomatch = where(nomatchp, nnomatch)
  minpos = matches[matchloc]
  mindist = distance[matchloc - matches[0]]
  if nnomatch gt 0 then begin
    minpos[nomatch] = -1
    mindist[nomatch] = 0.
  endif
  <span class="comments">; if many-to-one matches allowed, no need to do anything else</span>
  if ~keyword_set(one2onep) then break  

  <span class="comments">; histogram of entries in list 2</span>
  h = histogram(minpos, min=0, max=n2-1, reverse_indices=ri)
  <span class="comments">; we're done if there are no multiple matches</span>
  if max(h) le 1 then break

  <span class="comments">; find entries with multiple matches and increment the non-closest</span>
  <span class="comments">; matches</span>
<span class="comments">; slower loop version:</span>
<span class="comments">;  multimatch = where(h gt 1, nmultimatch)</span>
<span class="comments">;  for mi=0l,nmultimatch-1 do begin</span>
<span class="comments">;    ; sort the distances associated with this entry</span>
<span class="comments">;    this2 = ri[ri[multimatch[mi]]:ri[multimatch[mi]+1]-1]</span>
<span class="comments">;    sortdist = sort(distance[matchloc[this2] - matches[0]])</span>
<span class="comments">;    notclosest = this2[sortdist[1:*]]</span>
<span class="comments">;    matchloc[notclosest]++</span>
<span class="comments">;    nincrements[notclosest]++</span>
<span class="comments">;  endfor</span>
<span class="comments">; faster histogram-of-histogram version:</span>
  h2 = histogram(h, min=2, omax=hmax, reverse_indices=ri2)
  nh2 = n_elements(h2)
  for repci=0l,nh2-1 do if h2[repci] gt 0 then begin
    targ = [h2[repci], repci+2]
    vec_inds = ri2[ri2[repci]:ri2[repci+1]-1]  <span class="comments">; indices into h</span>
    these1 = ri[rebin(ri[vec_inds], targ, /sample) + $
      rebin(transpose(lindgen(repci+2)), targ, /sample)]
    these2 = rebin(vec_inds, targ, /sample)
    <span class="comments">; now sort the distances for each entry in these2</span>
    sortdist = sort_nd(distance[matchloc[these1]-matches[0]], 2)
    notclosest = these1[sortdist[*,1:*]]
    matchloc[notclosest]++
    nincrements[notclosest]++    
  endif

  <span class="comments">; if we've gone past the end of the points within sphrad, mark it as a nomatch</span>
  nomatchp or= nincrements ge nwithin
endrep until 0 ne 0

return, minpos

end

</code>
    </div>
  </body>
</html>
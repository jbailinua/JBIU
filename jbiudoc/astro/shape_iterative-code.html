<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:40 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>shape_iterative.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="shape_iterative.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      SHAPE_ITERATIVE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Given a 3-dimensional distribution of points, determines the best</span>
<span class="comments">;      ellipsoidal shape using particles in an interatively-defined ellipsoid</span>
<span class="comments">;      (or ellipsoidal shell) of the same shape.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;      Astro</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      Result = SHAPE_ITERATIVE(Pos, Radius)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;      Pos:       An Nx3 array specifying the 3d positions of the N particles</span>
<span class="comments">;                 that make up the mass distribution.</span>
<span class="comments">;</span>
<span class="comments">;      Radius:    Radius at which to compute the shape. For a filled ellipsoid,</span>
<span class="comments">;                 this is the geometric mean radius of the principal axes that</span>
<span class="comments">;                 define the outer limits of the ellipsoid; for an ellipsoidal shell,</span>
<span class="comments">;                 this is the geometric mean radius at the center of the shell.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;      SHELL:   Use an ellipsoidal shell rather than a filled ellipsoid. The</span>
<span class="comments">;               value is the width of the shell.</span>
<span class="comments">;</span>
<span class="comments">;      AXES:    An output 3x3 array containing the principal axes.</span>
<span class="comments">;               AXES[*,i] is the direction of the i-th principal axis.</span>
<span class="comments">;</span>
<span class="comments">;      MASSES:  An N-element vector of the mass of each point. If not</span>
<span class="comments">;               specified, all masses are assumed to be unity.</span>
<span class="comments">;</span>
<span class="comments">;      R2WEIGHT:  If /R2WEIGHT is specified then particles are downweighted</span>
<span class="comments">;                 by a factor of 1/r^2 so that all particles have equal</span>
<span class="comments">;                 effect regardless of radius.</span>
<span class="comments">;</span>
<span class="comments">;      FVAL:      Iterate until the axis ratios and directions of the axes</span>
<span class="comments">;                 vary by less than FVAL. Default is 0.001.</span>
<span class="comments">;</span>
<span class="comments">;      MAXIT:     Maximum number of iterations to allow. Default is 20.</span>
<span class="comments">;</span>
<span class="comments">;      VERBOSE:   Print information about each iteration.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;      The function returns a 3-element array containing the lengths of the</span>
<span class="comments">;      principal axes of the ellipse.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;      Set up a 1/r^2 ellipsoidal density distribution and find its shape.</span>
<span class="comments">;</span>
<span class="comments">;      np = 100000</span>
<span class="comments">;      r = 200 * randomu(seed, np)</span>
<span class="comments">;      ph = 2. * !pi * randomu(seed, np)</span>
<span class="comments">;      th = acos(randomu(seed, np))</span>
<span class="comments">;      x = 2. * r * cos(ph) * sin(th)</span>
<span class="comments">;      y = r * sin(ph) * sin(th)</span>
<span class="comments">;      z = 3. * r * cos(th)</span>
<span class="comments">;      print, shape_iterative([[x],[y],[z]], 100., axes=axes)</span>
<span class="comments">;      print, axes</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;      Written by:    Jeremy Bailin</span>
<span class="comments">;      22 July 2011   Initial release</span>
<span class="comments">;-</span>
<a id="shape_iterative:source"></a>function shape_iterative, pos, radius, masses=masses, r2weight=r2weight, shell=dshell, $
  axes=evec, fval=fval, maxit=maxit, verbose=verbose

ndimen=3  <span class="comments">; might try to generalize to arbitrary dimensions later</span>
np = (size(pos,/dimen))[0]

setdefaultvalue, fval, 1e-3
setdefaultvalue, maxit, 20

<span class="comments">; for first iteration, use a sphere</span>
evec = identity(ndimen)
axrat = replicate(1., ndimen)

<span class="comments">; precompute some squares</span>
if keyword_set(dshell) then begin
  inner_r2 = (radius-0.5*dshell)^2
  outer_r2 = (radius+0.5*dshell)^2
endif else outer_r2 = radius^2

<span class="comments">; iteration 0 info statement</span>
if keyword_set(verbose) then print, string(0, axrat, format='(%"Iteration %0d   Axis ratios: %0.3f %0.3f %0.3f")')

for itnum=1,maxit do begin
  <span class="comments">; save values for convergence check</span>
  oldaxrat = axrat
  oldevec = evec    

  <span class="comments">; define particles that are in the current ellipsoid(al shell)</span>
  <span class="comments">; first project along principal axes</span>
  projpos = pos # evec
  <span class="comments">; scale axis ratios so the volume is equal to 1 and make into Nx3 array</span>
  axscale = rebin(reform(axrat / product(axrat)^(1./ndimen), 1, ndimen), np, ndimen, /sample)
  if keyword_set(dshell) then begin
    <span class="comments">; use ellipsoidal shell</span>
    use = where(between(inner_r2, total( (projpos/axscale)^2, 2), outer_r2), nuse)
  endif else begin
    <span class="comments">; use ellipsoidal volume</span>
    use = where(total( (projpos/axscale)^2, 2) le outer_r2, nuse)
  endelse
  if nuse eq 0 then message, 'No usable points.'

  <span class="comments">; calculate the second moment tensor</span>
  itens = inertiatens(pos[use,*], masses=masses, r2weight=r2weight)
  <span class="comments">; calculate eigenvalues and eigenvectors</span>
  eval = eigenql(itens, eigenvec=evec)
  <span class="comments">; turn into axis ratios</span>
  axrat = sqrt(eval/eval[0])
  
  <span class="comments">; info statement </span>
  if keyword_set(verbose) then print, string(itnum, axrat, format='(%"Iteration %0d   Axis ratios: %0.3f %0.3f %0.3f")')

  <span class="comments">; check for convergence</span>
  if max(abs(axrat-oldaxrat)) lt fval and max(abs(evec-oldevec)) lt fval then break
endfor

<span class="comments">; return axis ratios</span>
return, axrat

end

</code>
    </div>
  </body>
</html>
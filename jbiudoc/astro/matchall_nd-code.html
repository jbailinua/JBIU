<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:39 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>matchall_nd.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="matchall_nd.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; normally: translates the array of indices aind into a</span>
<span class="comments">; single 1D index (the inverse operation of array_indices).</span>
<span class="comments">; If usemap is set, then it maps that 1D index using value_locate</span>
<span class="comments">; (i.e. returns the entry within the map corresponding to the</span>
<span class="comments">; 1D index) and returns -1 if it doesn't exist in the map.</span>
<a id="matchallmap:source"></a>function matchallmap, ngrid, aind, usemap=map
  <span class="comments">; inverse of array_indices:</span>
  index = total( aind * rebin( 1#[1,product(ngrid[0:n_elements(ngrid)-2], $
    /cumul, /int)], size(aind,/dimen), /sample), 2, /int)
  if n_elements(map) eq 0 then return, index
  result = value_locate(map, index)
  missing = where(map[result] ne index, nmissing)
  if nmissing gt 0 then result[missing]=-1
  return, result
end


<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    MATCHALL_ND</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Determines which of a set of coordinates of arbitratry dimension are a</span>
<span class="comments">;    given distance from each of a vector of points. Based on JD's MATCH_2D</span>
<span class="comments">;    and my MATCHALL_SPH.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Astro</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    Result = MATCHALL_ND(P1, P2, MaxDistance, Nwithin)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    P1:     N1xD array of D-dimensional coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    P2:     N2xD array of D-dimensional coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    MaxDistance:  Maximum D-dimensional distance.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;    The function returns the list of indices of P2 that lie within</span>
<span class="comments">;    Distance of each point in P1. The format of the returned array is</span>
<span class="comments">;    similar to the REVERSE_INDICES array from HISTOGRAM: the indices</span>
<span class="comments">;    into P2 that are close enough to element i of P1 are</span>
<span class="comments">;    contained in Result[Result[i]:Result[i+1]-1] (note, however, that</span>
<span class="comments">;    these indices are not guaranteed to be sorted). If there are no matches,</span>
<span class="comments">;    then Result[i] eq Result[i+1].</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;    Nwithin: A vector containing the number of matches for each entry in P1.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;    DISTANCE:  Optional output containing the distances between each pair.</span>
<span class="comments">;               The distances are stored in the same order as the Result</span>
<span class="comments">;               array but starting at 0, i.e. if j is match number k to</span>
<span class="comments">;               element i then</span>
<span class="comments">;                   j = Result[Result[i]+k]</span>
<span class="comments">;               and the distance between points i and j is</span>
<span class="comments">;                   DISTANCE[Result[i]+k-Result[0]]</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;    Generates Gaussian 3D clouds around each of several locations and colours</span>
<span class="comments">;    the points in the cloud that lie within the Gaussian dispersion of any</span>
<span class="comments">;    location.</span>
<span class="comments">;</span>
<span class="comments">;    na = 10</span>
<span class="comments">;    nbpera = 1000</span>
<span class="comments">;    a = randomn(seed, na, 3)</span>
<span class="comments">;    b = 0.1*randomn(seed, na*nbpera, 3)</span>
<span class="comments">;    b += rebin(a, na*nbpera, 3, /sample)</span>
<span class="comments">;    result = matchall_nd(a, b, 0.1)</span>
<span class="comments">;    matches = result[na+1:*]</span>
<span class="comments">;    iplot, /scatter, /iso, b[*,0], b[*,1], b[*,2]</span>
<span class="comments">;    iplot, /overplot, /scatter, sym_color=[255,0,0], b[matches,0], $</span>
<span class="comments">;      b[matches,1], b[matches,2]</span>
<span class="comments">;    iplot, /overplot, sym_index=1, sym_color=[0,0,255], linestyle=6, a[*,0], $</span>
<span class="comments">;      a[*,1], a[*,2]   </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;    Written by:    Jeremy Bailin</span>
<span class="comments">;    10 June 2008   Public release in JBIU as WITHINSPHRAD</span>
<span class="comments">;    24 April 2009  Vectorized as WITHINSPHRAD_VEC</span>
<span class="comments">;    25 April 2009  Polished to improve memory use</span>
<span class="comments">;    9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing</span>
<span class="comments">;                   heavily from JD Smith's MATCH_2D</span>
<span class="comments">;    13 May 2009    Removed * from LHS index in final remapping for speed</span>
<span class="comments">;    6 May 2010     Changed to MATCHALL_2D and just using Euclidean 2D</span>
<span class="comments">;                   coordinates (add a bunch of stuff back in from MATCH_2D and</span>
<span class="comments">;                   take out a bunch of angle stuff)</span>
<span class="comments">;    25 May 2010    Bug fix to allow X2 and Y2 to have any dimension.</span>
<span class="comments">;    23 August 2010 Generalized to an arbitrary number of dimensions and</span>
<span class="comments">;                   to use the manifold-mapping technique from WITHINSPHRAD_VEC3D</span>
<span class="comments">;                   if the space is sparse enough as MATCHALL_ND.</span>
<span class="comments">;    9 Feb 2010     Added DISTANCE output keyword.</span>
<span class="comments">;-</span>
<a id="matchall_nd:source"></a>function matchall_nd, p1, p2, maxdistance, nwithin, distance=distance

manifoldfrac=0.25   <span class="comments">; use the remapping trick if less than this fraction</span>
                    <span class="comments">; of the cells would be occupied</span>

if (size(maxdistance))[0] ne 0 then message, 'MaxDistance must be a scalar.'
p1size = size(p1,/dimen)
p2size = size(p2,/dimen)
if n_elements(p1size) ne 2 then $
  message, 'P1 must be an N1xD dimensional array.'
if n_elements(p2size) ne 2 then $
  message, 'P2 must be an N2xD dimensional array.'
if p1size[1] ne p2size[1] then $
  message, 'P1 and P2 must have the same number of dimensions.'

ndimen = p1size[1]
n1 = p1size[0]
n2 = p2size[0]

gridlen = 2.*maxdistance
mx=max(p2,dimen=1, min=mn)
mn-=1.5*gridlen
mx+=1.5*gridlen

ngrid = ceil( (mx-mn)/gridlen )

<span class="comments">; which bins do points 1 and 2 fall in?</span>
off1 = (p1 - rebin(1#mn,n1,ndimen,/sample))/gridlen
off2 = (p2 - rebin(1#mn,n2,ndimen,/sample))/gridlen
bin1 = floor(off1)
bin2 = floor(off2)

<span class="comments">; calculate 1D indices</span>
indices1 = matchallmap(ngrid, bin1)
indices2 = matchallmap(ngrid, bin2)
<span class="comments">; calculate 1D indices that are used</span>
allindices = [indices1,indices2]
allindices = allindices[uniq(allindices,sort(allindices))]
<span class="comments">; how densely packed are they, ie. what fraction of bins are used?</span>
fracbinused = n_elements(allindices) / product(ngrid)
<span class="comments">; map if only a small fraction are used</span>
if fracbinused lt manifoldfrac then map=temporary(allindices)

<span class="comments">; map the indices of P2 if necessary (just do it here rather</span>
<span class="comments">; than in matchallmap because we've already calculated the</span>
<span class="comments">; 1D indices, and we know by construction that every element</span>
<span class="comments">; in indices2 must appear in the map)</span>
if n_elements(map) ne 0 then indices2=value_locate(map,indices2)

<span class="comments">; histogram points 2</span>
<span class="comments">; note the extra 0 out front - used so that when we look for bin -1</span>
<span class="comments">; we know there are 0 entries there.</span>
h = [0, histogram(indices2, omin=hmin, reverse_indices=ri)]

<span class="comments">; calculate which half of each bin the points are in</span>
off1 = 1 - 2*((off1-bin1) lt 0.5)

rad2 = maxdistance^2

<span class="comments">; loop through all neighbouring cells</span>
ncell = 2L^ndimen
powersof2 = 2L^indgen(ndimen)
for ci=0L,ncell-1 do begin
  <span class="comments">; array of cell direction we're working on in each dimension</span>
  di = (ci and powersof2)/powersof2
  
  b = matchallmap(ngrid, bin1+rebin(1#di,n1,ndimen,/sample)*off1, usemap=map)

  <span class="comments">; dual histogram method, loop by count in search bins (see JD's code)</span>
  h2 = histogram(h[(b-hmin+1) > 0], omin=om, reverse_indices=ri2)

  <span class="comments">; loop through repeat counts</span>
  for k=long(om eq 0), n_elements(h2)-1 do if h2[k] gt 0 then begin
    these_bins = ri2[ri2[k]:ri2[k+1]-1]

    if k+om eq 1 then begin <span class="comments">; single point</span>
      these_points = ri[ri[b[these_bins]-hmin]]
    endif else begin
      targ=[h2[k],k+om]
      these_points = ri[ri[rebin(b[these_bins]-hmin,targ,/sample)]+ $
        rebin(lindgen(1,k+om),targ,/sample)]
      these_bins = rebin(temporary(these_bins),targ,/sample)
    endelse

    <span class="comments">; figure out which ones are really within</span>
    these_dist2 = total( (p2[these_points,*]-p1[these_bins,*])^2, 2)
    within = where(these_dist2 le rad2, nwithin)

    if nwithin gt 0 then begin
      <span class="comments">; have there been any pairs yet?</span>
      if n_elements(plausible) eq 0 then begin
        plausible = [[these_bins[within]],[these_points[within]],[these_dist2[within]]]
      endif else begin
        <span class="comments">; concatenation is inefficient, but we do it at most ncell x N1 times</span>
        plausible = [plausible,[[these_bins[within]],[these_points[within]], $
          [these_dist2[within]]]]
      endelse
    endif

  endif
endfor

if n_elements(plausible) eq 0 then begin
  nwithin=replicate(0l,n1)
  return, replicate(-1,n1+1)
endif else begin
  <span class="comments">; use histogram to generate a reverse_indices array that contains</span>
  <span class="comments">; the relevant entries, and then map into the appropriate elements</span>
  <span class="comments">; in 2</span>
  nwithin = histogram(plausible[*,0], min=0, max=n1-1, reverse_indices=npri)
  distance = sqrt(plausible[npri[n1+1:*],2])
  npri[n1+1] = plausible[npri[n1+1:*],1]
  return, npri
endelse

end

</code>
    </div>
  </body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:39 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>jbimatch.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="jbimatch.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="calculate_matrix:source"></a>pro calculate_matrix, info
  <span class="comments">; build up the linear matrix for the slopes</span>
  comps_good = where(info.comps2use, ncomps_good)
  comps_good_ai = array_indices(info.comps2use, comps_good)
  slope_amatrix = fltarr(info.nimages, ncomps_good+1)
  slope_bmatrix = fltarr(ncomps_good+1)
  <span class="comments">; set a_0=1</span>
  slope_amatrix[*,0] = [1, replicate(0, info.nimages-1)]
  slope_bmatrix[0] = 1.
  <span class="comments">; remaining</span>
  <span class="comments">; i2 = slope i_1</span>
  <span class="comments">; =>  -slope i_1 + i_2 = 0</span>
  <span class="comments">; so in the matrix, i1 should be set to minus the slope, and i2 should be set to 1</span>
  <span class="comments">; i1 is comps_good_ai[0,*] and i2 is comps_good_ai[1,*]</span>
  slope_amatrix[(comps_good_ai[0,*])[*],lindgen(ncomps_good)+1] = -info.slope_comparisons[comps_good]
  slope_amatrix[(comps_good_ai[1,*])[*],lindgen(ncomps_good)+1] = 1.
  <span class="comments">; solve slope matrix via SVD</span>
  svdc, slope_amatrix, w, u, v
  inverse_scale = svsol(u, w, v, slope_bmatrix)
  <span class="comments">; rescale so that inverse_scale[0] is identically 1.</span>
  inverse_scale /= inverse_scale[0]

  if info.zero then begin
    <span class="comments">; build up the linear matrix for the zero points</span>
    zp_amatrix = fltarr(info.nimages, ncomps_good+1)
    zp_bmatrix = fltarr(ncomps_good+1)
    <span class="comments">; set a_0 = 0</span>
    zp_amatrix[*,0] = [1, replicate(0, info.nimages-1)]
    <span class="comments">; remaining</span>
    <span class="comments">; a_1 x_1 + b_1 = a_2 x_2 + b_2</span>
    <span class="comments">; x_2 = a_1/a_2 x_1 + (b_1 - b_2) / a_2</span>
    <span class="comments">; Fit to x_2 = m_12 x_1 + b_12</span>
    <span class="comments">; Once we know a_2: b_1 - b_2 = b_12 a_2</span>
    <span class="comments">; so in the matrix, i1 should be set to 1, i2 should be set to -1</span>
    zp_amatrix[(comps_good_ai[0,*])[*],lindgen(ncomps_good)+1] = 1.
    zp_amatrix[(comps_good_ai[1,*])[*],lindgen(ncomps_good)+1] = -1.
    zp_bmatrix[1:*] = info.zero_comparisons[comps_good] * inverse_scale[(comps_good_ai[1,*])[*]]
    <span class="comments">; solve zero matrix via SVD</span>
    svdc, zp_amatrix, w, u, v
    info.msczero = svsol(u, w, v, zp_bmatrix)
  endif else info.msczero = replicate(0., info.nimages)

  <span class="comments">; mscscale is the inverse of inverse_scale</span>
  info.mscscale = 1. / inverse_scale

  astrolib
  print, 'Image              MSCSCALE   MSCZERO'
  forprint, info.data.imagename[info.imri[info.imri[0:info.nimages-1]]], $
    string(info.mscscale,format='(F10.5)'), string(info.msczero,format='(F10.5)'), /nocomment
end
  


<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="jbimatch_gui_cleanup:source"></a>pro jbimatch_gui_cleanup, tlb
<span class="comments">; clean up pointers</span>
  widget_control, tlb, get_uvalue=info, /no_copy
  if n_elements(info) eq 0 then return
  ptr_free, info.in1good
  ptr_free, info.in2good
end

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="jbimatch_display_plot:source"></a>pro jbimatch_display_plot, info
  <span class="comments">; compare images i1 and i2</span>
  in1 = info.imri[info.imri[info.i1]:info.imri[info.i1+1]-1]
  in2 = info.imri[info.imri[info.i2]:info.imri[info.i2+1]-1]

  <span class="comments">; find communal regions</span>
  regmap = value_locate(info.data.region[in1], info.data.region[in2])
  regmap_good = where(info.data.region[in1[regmap]] eq info.data.region[in2])

  <span class="comments">; store matching values in info</span>
  *info.in1good = in1[regmap[regmap_good]]
  *info.in2good = in2[regmap_good]

  <span class="comments">; title line telling how many we're at</span>
  totnumplots = info.nimages*(info.nimages-1)/2
  title = string(info.compplotnum, totnumplots, format='(%"%0d / %0d")')

  <span class="comments">; plot them</span>
  wset, info.plot_drawwidget_wid
  cgplot, xtitle=info.data.imagename[in1[0]], ytitle=info.data.imagename[in2[0]], $
    info.data.data2[*info.in1good], info.data.data2[*info.in2good], psym=1, title=title

  <span class="comments">; make sure button activations are right. we must be in stage 0, so only skip is active</span>
  widget_control, info.eye_button_id, sensitive=0
  widget_control, info.computed_button_id, sensitive=0
  widget_control, info.redo_button_id, sensitive=0
  widget_control, info.skip_button_id, sensitive=1
  widget_control, info.next_button_id, sensitive=0
end 

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="jbimatch_display_approval:source"></a>pro jbimatch_display_approval, info
  <span class="comments">; compare images i1 and i2</span>
  in1 = info.imri[info.imri[info.i1]:info.imri[info.i1+1]-1]
  in2 = info.imri[info.imri[info.i2]:info.imri[info.i2+1]-1]

  <span class="comments">; find communal regions</span>
  regmap = value_locate(info.data.region[in1], info.data.region[in2])
  regmap_good = where(info.data.region[in1[regmap]] eq info.data.region[in2])

  <span class="comments">; store matching values in info</span>
  *info.in1good = in1[regmap[regmap_good]]
  *info.in2good = in2[regmap_good]

  <span class="comments">; title line telling how many we're at</span>
  totnumplots = info.nimages*(info.nimages-1)/2
  title = string(info.compplotnum, totnumplots, format='(%"%0d / %0d")')

  <span class="comments">; plot them</span>
  fitline = [(info.msczero[info.i1]-info.msczero[info.i2])*info.mscscale[info.i2], $
    info.mscscale[info.i1]/info.mscscale[info.i2]]

  wset, info.plot_drawwidget_wid
  cgplot, xtitle=info.data.imagename[in1[0]], ytitle=info.data.imagename[in2[0]], $
    info.data.data2[*info.in1good], info.data.data2[*info.in2good], psym=1, title=title
  xax = !x.crange
  cgplot, /over, color='blue', xax, fitline[0]+fitline[1]*xax
  cgplot, /over, color='red', xax, info.zero_comparisons[info.i1,info.i2]+ $
    info.slope_comparisons[info.i1,info.i2]*xax

  al_legend, /top, /left, box=0, color=['blue','red'], ['Global fit','Selected fit'], lines=0
end 


<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="drawwidget_events:source"></a>pro drawwidget_events, event
  if event.type eq 1 then begin  <span class="comments">; button release</span>
    Widget_Control, event.ID, Get_UValue=draw_info, /No_Copy
    widget_control, event.top, get_uvalue=info, /no_copy

    wset, info.plot_drawwidget_wid
    xy_data = convert_coord(event.x, event.y, /device, /to_data)

    case info.stage of
      0:begin
        draw_info.xcurs1 = xy_data[0]
        draw_info.ycurs1 = xy_data[1]
         
        wset, info.plot_drawwidget_wid
        cgplot, [draw_info.xcurs1], [draw_info.ycurs1], color='red', psym=5, /over

        info.stage = 1
        end
      1:begin
        draw_info.xcurs2 = xy_data[0]
        draw_info.ycurs2 = xy_data[1]

        wset, info.plot_drawwidget_wid
        cgplot, [draw_info.xcurs2], [draw_info.ycurs2], color='red', psym=5, /over

        <span class="comments">; overplot selected line.</span>
        info.cursline = linfit([draw_info.xcurs1,draw_info.xcurs2], [draw_info.ycurs1,draw_info.ycurs2])
        xax = !x.crange
        cgplot, /over, lines=2, color='red', xax, info.cursline[0]+info.cursline[1]*xax
  
        <span class="comments">; select only points within 3sigma of this line for optimal fit</span>
        maxsig = 3.
        deviation = info.data.data2[*info.in2good] - (info.cursline[0]+info.cursline[1]*info.data.data2[*info.in1good])
        sigma = stddev(deviation)
        within_maxsig = where(abs(deviation) le maxsig*sigma, nwithin_maxsig)
       
        info.computeline = robust_linefit(info.data.data2[(*info.in1good)[within_maxsig]], $
          info.data.data2[(*info.in2good)[within_maxsig]], /bisect)

        <span class="comments">; overplot computed fit</span>
        cgplot, /over, color='blue', xax, info.computeline[0]+info.computeline[1]*xax
        al_legend, color=['red','blue'], lines=[2,0], ['Eye fit','Computed fit'], /top, /left, box=0

        <span class="comments">; advance stage and activate buttons</span>
        info.stage = 2
        widget_control, info.eye_button_id, sensitive=1
        widget_control, info.computed_button_id, sensitive=1
        widget_control, info.redo_button_id, sensitive=1
        widget_control, info.skip_button_id, sensitive=1
        end
      else:
    endcase

    <span class="comments">; return info structures</span>
    Widget_Control, event.ID, set_UValue=draw_info, /No_Copy
    widget_control, event.top, set_uvalue=info, /no_copy
  endif
end

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="i1i2_increment:source"></a>pro i1i2_increment, info, done
  <span class="comments">; equivalent to these for loops:</span>
  <span class="comments">; for i1=0l,nimages-2 do if imhist[i1] gt 0 then begin</span>
  <span class="comments">;   for i2=i1+1,nimages-1 do if imhist[i2] gt 0 then begin</span>
  repeat begin
    info.i2++
    if info.i2 eq info.nimages then begin
      info.i1++
      if info.i1 eq info.nimages-1 then begin
        done=1
        return
      endif
      info.i2 = info.i1+1
    endif
  endrep until info.imhist[info.i1] gt 0 and info.imhist[info.i2] gt 0
  done=0
  info.compplotnum++
end



<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="leftpanel_button_events:source"></a>pro leftpanel_button_events, event
  widget_control, event.top, get_uvalue=info, /no_copy

  case event.id of
    info.eye_button_id:begin
                       <span class="comments">; use cursline as fit</span>
                       info.slope_comparisons[info.i1,info.i2] = info.cursline[1]
                       if info.zero then info.zero_comparisons[info.i1,info.i2] = info.cursline[0]
                       info.comps2use[info.i1,info.i2]=1
                       <span class="comments">; increment i1 and i2 to the next valid comparison</span>
                       i1i2_increment, info, done
                       if done then begin
                         info.stage=3
                         break
                       endif
                       jbimatch_display_plot, info
                       end
    info.computed_button_id:begin
                       <span class="comments">; use computeline as fit</span>
                       info.slope_comparisons[info.i1,info.i2] = info.computeline[1]
                       if info.zero then info.zero_comparisons[info.i1,info.i2] = info.computeline[0]
                       info.comps2use[info.i1,info.i2]=1
                       <span class="comments">; increment i1 and i2 to the next valid comparison</span>
                       i1i2_increment, info, done
                       if done then begin
                         info.stage=3
                         break
                       endif
                       jbimatch_display_plot, info
                            end
    info.redo_button_id:begin
                        <span class="comments">; just redisplay it</span>
                        jbimatch_display_plot, info
                        end
    info.skip_button_id:begin
                        <span class="comments">; increment i1 and i2 to the next valid comparison</span>
                        i1i2_increment, info, done
                        if done then begin
                          info.stage=3
                          break
                        endif
                        jbimatch_display_plot, info
                        end
  endcase

  <span class="comments">; now go to stage 0 (waiting for first point) unless we're done</span>
  if info.stage lt 3 then info.stage = 0

  <span class="comments">; if we're done, update button sensitivities, calculate matrix and display first approval plot</span>
  if info.stage eq 3 then begin
    widget_control, info.eye_button_id, sensitive=0
    widget_control, info.computed_button_id, sensitive=0
    widget_control, info.redo_button_id, sensitive=0
    widget_control, info.skip_button_id, sensitive=0
    widget_control, info.next_button_id, sensitive=1
    info.i1 = 0
    info.i2 = 1
    info.compplotnum=1
    calculate_matrix, info
    jbimatch_display_approval, info
  endif

  widget_control, event.top, set_uvalue=info, /no_copy
end


<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="nextbutton_events:source"></a>pro nextbutton_events, event
  widget_control, event.top, get_uvalue=info, /no_copy

  i1i2_increment, info, done
  if done then begin
    info.stage=4
    <span class="comments">; create dialog asking whether to update</span>
    update_headers = dialog_message(dialog_parent=event.top, /question, $
      'Update FITS file headers?', /default_no)
    if strupcase(update_headers) eq 'YES' then begin
      for ii=0l,info.nimages-1 do begin
        head = headfits(info.data.imagename[info.imri[info.imri[ii]]])
        sxaddpar, head, 'MSCSCALE', info.mscscale[ii]
        sxaddpar, head, 'MSCZERO', info.msczero[ii]
        modfits, info.data.imagename[info.imri[info.imri[ii]]], 0, head
      endfor
    endif

    <span class="comments">; and destroy the tlb - we're done!</span>
    widget_control, event.top, /destroy
  endif else begin
    jbimatch_display_approval, info
    widget_control, event.top, set_uvalue=info, /no_copy
  endelse
end



<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">; Determines the relative scaling of different images based on the measured</span>
<span class="comments">; output of the IRAF task MSCIMATCH.</span>
<span class="comments">;</span>
<span class="comments">; All scalings (and optionally zero points, if /ZERO is set) will be printed to</span>
<span class="comments">; the screen. If the user requests it via the dialog, the MSCSCALE and MSCZERO</span>
<span class="comments">; keywords of the FITS files will also be modified</span>

<span class="comments">; :Categories:</span>
<span class="comments">;    Astro</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   datfile: in, required, type=string</span>
<span class="comments">;      Name of the datfile generated using MSCIMATCH with the "measured" keyword.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   zero: in, optional, type=boolean</span>
<span class="comments">;      Fit zero points if /ZERO is set. Otherwise, just fit slopes.</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;    Jeremy Bailin</span>
<span class="comments">;  </span>
<span class="comments">; :History:</span>
<span class="comments">;    14 Oct 2011   First release</span>
<span class="comments">;    18 Oct 2011   Turned into widget program</span>
<span class="comments">;    20 Oct 2011   Comments re-written, put into JBIU</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="jbimatch:source"></a>pro jbimatch, datfile, zero=zero

Catch, theError 
IF theError NE 0 THEN BEGIN 
   Catch, /Cancel 
   ok = Error_Message(Traceback=1) 
   RETURN 
ENDIF 


<span class="comments">; template for reading Datfile, as generated by ascii_template</span>
imatch_template = {version:1., datastart:1L, delimiter:32b, missingvalue:!values.f_nan, $
  commentsymbol:'', fieldcount:10L, fieldtypes:long([3,3,7,7,7,3,3,4,4,4]), $
  fieldnames:['imagenum','region','imagename','ra','dec','xc','yc','sky','data1','data2'], $
  fieldlocations:long([1,4,8,27,38,50,57,60,64,73]), fieldgroups:lindgen(10)}
<span class="comments">; read in data file</span>
data = read_ascii(datfile, template=imatch_template)
<span class="comments">; make imagenum start at 0</span>
data.imagenum--

nimages = max(data.imagenum)+1

<span class="comments">; figure out which lines correspond to which images</span>
imhist = histogram(data.imagenum, min=0, max=nimages-1, bin=1, reverse=imri)

<span class="comments">; arrays to store relative scalings and zero points from fits</span>
slope_comparisons = fltarr(nimages,nimages)
zero_comparisons = fltarr(nimages,nimages)
comps2use = bytarr(nimages,nimages)   <span class="comments">; keep track of skipped ones</span>
mscscale = fltarr(nimages)
msczero = fltarr(nimages)
i1=0L
i2=1L
stage=0  <span class="comments">;0=waiting for first point, 1=waiting for second point,</span>
  <span class="comments">;2=waiting for button, 3=waiting for approval next, 4=waiting for whether to update files</span>


<span class="comments">; create widgets:</span>
<span class="comments">;  main window will have left section for buttons, right section for plots</span>
tlb = Widget_Base(row=1, Title='JBIMATCH')
<span class="comments">; left panel is a base widget for buttons</span>
leftpanel_basewidget_id = widget_base(tlb, column=1, event_pro='leftpanel_button_events')
eye_button_id = widget_button(leftpanel_basewidget_id, sensitive=0, value='Eye Fit')
computed_button_id = widget_button(leftpanel_basewidget_id, sensitive=0, value='Computed Fit')
redo_button_id = widget_button(leftpanel_basewidget_id, sensitive=0, value='Redo Fit')
skip_button_id = widget_button(leftpanel_basewidget_id, sensitive=1, value='Skip')
next_button_id = widget_button(leftpanel_basewidget_id, sensitive=0, value='Next', event_pro='nextbutton_events')
<span class="comments">; right panel is a draw widget</span>
plot_drawwidget_id = widget_draw(tlb, /button_events, xsize=500, ysize=500, event_pro='drawwidget_events')

<span class="comments">; tlb info structure for passing information</span>
info = { zero:keyword_set(zero), data:data, nimages:nimages, imhist:imhist, imri:imri, $
  slope_comparisons:slope_comparisons, zero_comparisons:zero_comparisons, $
  comps2use:comps2use, stage:stage, plot_drawwidget_wid:-1L, $
  eye_button_id:eye_button_id, computed_button_id:computed_button_id, $
  redo_button_id:redo_button_id, skip_button_id:skip_button_id, $
  next_button_id:next_button_id, i1:i1, i2:i2, mscscale:mscscale, $
  msczero:msczero, in1good:ptr_new(in1good), in2good:ptr_new(in2good), $
  cursline:[0.,0.], computeline:[0.,0.], compplotnum:1L }

<span class="comments">; draw widget info structure for storing button clicks</span>
draw_info = { xcurs1:0., ycurs1:0., xcurs2:0., ycurs2:0.}

widget_control, plot_drawwidget_id, set_uvalue=draw_info, /no_copy
  
<span class="comments">; display widgets</span>
widget_control, tlb, /realize

<span class="comments">; display the first plot</span>
Widget_Control, plot_drawwidget_id, Get_Value=plot_drawwidget_wid
info.plot_drawwidget_wid=plot_drawwidget_wid
jbimatch_display_plot, info

Widget_Control, tlb, Set_UValue=info, /No_Copy 

<span class="comments">; start event loop</span>
xmanager, 'jbimatch', tlb, cleanup='jbimatch_gui_cleanup'

end


</code>
    </div>
  </body>
</html>
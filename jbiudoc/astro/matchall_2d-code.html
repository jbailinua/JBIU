<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:39 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>matchall_2d.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="matchall_2d.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    MATCHALL_2D</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Determines which of a set of 2D coordinates are within a given distance from</span>
<span class="comments">;    each of a vector of points. Based on JD's MATCH_2D and my MATCHALL_SPH.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Astro</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    Result = MATCHALL_2D(X1, Y1, X2, Y2, MaxDistance, Nwithin)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    X1:     Vector of X coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    Y1:     Vector of Y coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    X2:     Vector of X coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    Y2:     Vector of Y coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    MaxDistance:  Maximum distance.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;    The function returns the list of indices of X2, Y2 that lie within</span>
<span class="comments">;    Sphrad of each point X1,Y1. The format of the returned array is</span>
<span class="comments">;    similar to the REVERSE_INDICES array from HISTOGRAM: the indices</span>
<span class="comments">;    into X2,Y2 that are close enough to element i of X1,Y1 are</span>
<span class="comments">;    contained in Result[Result[i]:Result[i+1]-1] (note, however, that</span>
<span class="comments">;    these indices are not guaranteed to be sorted). If there are no matches,</span>
<span class="comments">;    then Result[i] eq Result[i+1].</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;    Nwithin: A vector containing the number of matches for each of X1,Y1.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;    DISTANCE:  Optional output containing the distances between each pair.</span>
<span class="comments">;               The distances are stored in the same order as the Result</span>
<span class="comments">;               array but starting at 0, i.e. if j is match number k to</span>
<span class="comments">;               element i then</span>
<span class="comments">;                   j = Result[Result[i]+k]</span>
<span class="comments">;               and the distance between points i and j is</span>
<span class="comments">;                   DISTANCE[Result[i]+k-Result[0]]</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;    Note that the routine is similar to finding</span>
<span class="comments">;      WHERE( (X2-X1[i])^2 + (Y2-Y1[i])^2 LE Distance^2, Nwithin)</span>
<span class="comments">;    for each element of X1 and Y1, but is much more efficient.</span>
<span class="comments">;</span>
<span class="comments">;    Shows which random points are within 0.1 of various coordinates:</span>
<span class="comments">;</span>
<span class="comments">;    seed=43</span>
<span class="comments">;    nrandcoords = 5000l</span>
<span class="comments">;    xrand = 2. * RANDOMU(seed, nrandcoords) - 1.</span>
<span class="comments">;    yrand = 2. * RANDOMU(seed, nrandcoords) - 1.</span>
<span class="comments">;    xcoords = [0.25, 0.5, 0.75]</span>
<span class="comments">;    ycoords = [0.75, 0.5, 0.25]</span>
<span class="comments">;    ncoords = N_ELEMENTS(xcoords)</span>
<span class="comments">;    matches = MATCHALL_2D(xcoords, ycoords, xrand, yrand, 0.1, nmatches)</span>
<span class="comments">;    PLOT, /ISO, PSYM=3, xrand, yrand</span>
<span class="comments">;    OPLOT, PSYM=1, COLOR=FSC_COLOR('blue'), xcoords, ycoords</span>
<span class="comments">;    OPLOT, PSYM=3, COLOR=FSC_COLOR('red'), xrand[matches[ncoords+1:*]], $</span>
<span class="comments">;      yrand[matches[ncoords+1:*]]</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;    Written by:    Jeremy Bailin</span>
<span class="comments">;    10 June 2008   Public release in JBIU as WITHINSPHRAD</span>
<span class="comments">;    24 April 2009  Vectorized as WITHINSPHRAD_VEC</span>
<span class="comments">;    25 April 2009  Polished to improve memory use</span>
<span class="comments">;    9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing</span>
<span class="comments">;                   heavily from JD Smith's MATCH_2D</span>
<span class="comments">;    13 May 2009    Removed * from LHS index in final remapping for speed</span>
<span class="comments">;    6 May 2010     Changed to MATCHALL_2D and just using Euclidean 2D coordinates</span>
<span class="comments">;                    (add a bunch of stuff back in from MATCH_2D and take out a bunch</span>
<span class="comments">;                    of angle stuff)</span>
<span class="comments">;    25 May 2010    Bug fix to allow X2 and Y2 to have any dimension.</span>
<span class="comments">;    9 Feb 2011     Added DISTANCE output keyword.</span>
<span class="comments">;-</span>
<a id="matchall_2d:source"></a>function matchall_2d, x1, y1, x2, y2, maxdistance, nwithin, distance=distance

if n_elements(x2) ne n_elements(y2) then $
  message, 'X2 and Y2 must have the same number of elements.'
if n_elements(x1) ne n_elements(y1) then $
  message, 'X1 and Y1 must have the same number of elements.'
if n_elements(maxdistance) ne 1 then $
  message, 'MaxDistance must contain one element.'

n1 = n_elements(x1)
n2 = n_elements(x2)

gridlen = 2.*maxdistance
mx=[max(x2,min=mnx2),max(y2,min=mny2)]
mn=[mnx2,mny2]
mn-=1.5*gridlen
mx+=1.5*gridlen

h = hist_nd([reform(x2,1,n_elements(x2)),reform(y2,1,n_elements(y2))], $
  gridlen,reverse_indices=ri,min=mn,max=mx)
d = size(h,/dimen)

<span class="comments">; bin locations of 1 in the 2 grid</span>
xoff = 0. > (x1-mn[0])/gridlen[0] &lt<span class="comments">; (d[0]-1.)</span>
yoff = 0. > (y1-mn[1])/(n_elements(gridlen) gt 1?gridlen[1]:gridlen) &lt<span class="comments">; (d[1]-1.)</span>
xbin = floor(xoff) & ybin=floor(yoff)
bin = xbin + d[0]*ybin   <span class="comments">; 1D index</span>

<span class="comments">; search 4 bins for closets match - check which quadrant</span>
xoff = 1 - 2*((xoff-xbin) lt 0.5)
yoff = 1 - 2*((yoff-ybin) lt 0.5)

rad2 = maxdistance^2

<span class="comments">; loop through all neighbouring cells in correct order</span>
for xi=0,1 do begin
  for yi=0,1 do begin
    b = 0l > (bin + xi*xoff + yi*yoff*d[0]) &lt<span class="comments">; (d[0]*d[1]-1)</span>

    <span class="comments">; dual histogram method, loop by count in search bins (see JD's code)</span>
    h2 = histogram(h[b], omin=om, reverse_indices=ri2)

    <span class="comments">; loop through repeat counts</span>
    for k=long(om eq 0), n_elements(h2)-1 do if h2[k] gt 0 then begin
      these_bins = ri2[ri2[k]:ri2[k+1]-1]

      if k+om eq 1 then begin <span class="comments">; single point</span>
        these_points = ri[ri[b[these_bins]]]
      endif else begin
        targ=[h2[k],k+om]
        these_points = ri[ri[rebin(b[these_bins],targ,/sample)]+ $
          rebin(lindgen(1,k+om),targ,/sample)]
        these_bins = rebin(temporary(these_bins),targ,/sample)
      endelse

      <span class="comments">; figure out which ones are really within</span>
      these_dist2 = (x2[these_points]-x1[these_bins])^2 + (y2[these_points] - $
        y1[these_bins])^2
      within = where(these_dist2 le rad2, nwithin)

      if nwithin gt 0 then begin
        <span class="comments">; have there been any pairs yet?</span>
        if n_elements(plausible) eq 0 then begin
          plausible = [[these_bins[within]],[these_points[within]],[these_dist2[within]]]
        endif else begin
          <span class="comments">; concatenation is inefficient, but we do it at most 4 x N1 times</span>
          plausible = [plausible,[[these_bins[within]],[these_points[within]], $
            [these_dist2[within]]]]
        endelse
      endif

    endif
  endfor
endfor

if n_elements(plausible) eq 0 then begin
  nwithin=replicate(0l,n1)
  return, replicate(-1,n1+1)
endif else begin
  <span class="comments">; use histogram to generate a reverse_indices array that contains</span>
  <span class="comments">; the relevant entries, and then map into the appropriate elements</span>
  <span class="comments">; in 2</span>
  nwithin = histogram(plausible[*,0], min=0, max=n1-1, reverse_indices=npri)
  distance = sqrt(plausible[npri[n1+1:*],2])
  npri[n1+1] = plausible[npri[n1+1:*],1]
  return, npri
endelse

end

</code>
    </div>
  </body>
</html>
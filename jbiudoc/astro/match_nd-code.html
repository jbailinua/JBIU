<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:39 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>match_nd.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="match_nd.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    MATCH_ND</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    For each arbitrarily-dimensioned point in one vector, determines the closest</span>
<span class="comments">;    point in a second vector. Method is to take the list returned by MATCHALL_ND</span>
<span class="comments">;    and narrow it down to the closest match.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Astro</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    Result = MATCH_ND(P1, P2, MaxDistance)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    P1:      N1 x D array of D-dimensional coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    P2:      N2 x D array of D-dimensional coordinates.</span>
<span class="comments">;</span>
<span class="comments">;    MaxDistance:  Maximum D-dimensional distance.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;    MINDIST:  Optional output containing an array of the actual distance</span>
<span class="comments">;              to the closest match for each element of P1.</span>
<span class="comments">;</span>
<span class="comments">;    ONE_TO_ONE:  Enforces one-to-one matching. By default, matching can</span>
<span class="comments">;                 be many-to-one, i.e. one entry in P2 can be the</span>
<span class="comments">;                 closest match to several entries in P1. If</span>
<span class="comments">;                 /ONE_TO_ONE is given, then each multiple entry in P2</span>
<span class="comments">;                 is first assigned to its closest point in P1. Then any</span>
<span class="comments">;                 entries in P1 that have lost their match are assigned</span>
<span class="comments">;                 the next closest point within MaxDistance. This process is</span>
<span class="comments">;                 iterated until all points in P1 are matched to a</span>
<span class="comments">;                 unique point in P2 or there are no more points</span>
<span class="comments">;                 within MaxDistance.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;    The function returns an array with one entry for each P1</span>
<span class="comments">;    element containing the index in P2 that is closest, or -1 if</span>
<span class="comments">;    there are none within MaxDistance.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;    na = 10</span>
<span class="comments">;    nb = 1000</span>
<span class="comments">;    a = randomn(seed, na, 3)</span>
<span class="comments">;    b = 2. * randomu(seed, nb, 3) - 1</span>
<span class="comments">;    matches = match_nd(a, b, 0.3)</span>
<span class="comments">;    iplot, /scatter, /iso, b[*,0], b[*,1], b[*,2]</span>
<span class="comments">;    iplot, /overplot, /scatter, a[*,0], a[*,1], a[*,2], sym_index=6, $</span>
<span class="comments">;      sym_color=[255,0,0]</span>
<span class="comments">;    for i=0L, na-1 do if matches[i] ne -1 then $</span>
<span class="comments">;      iplot, /overplot, [a[i,0], b[matches[i],0]], [a[i,1], b[matches[i],1]], $</span>
<span class="comments">;        [a[i,2], b[matches[i],2]], sym_index=0, color=[255,0,0]</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;    Written by:    Jeremy Bailin</span>
<span class="comments">;    10 June 2008   Public release in JBIU as WITHINSPHRAD</span>
<span class="comments">;    24 April 2009  Vectorized as WITHINSPHRAD_VEC</span>
<span class="comments">;    25 April 2009  Polished to improve memory use</span>
<span class="comments">;    9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing</span>
<span class="comments">;                   heavily from JD Smith's MATCH_2D</span>
<span class="comments">;    13 May 2009    Removed * from LHS index in final remapping for speed</span>
<span class="comments">;    23 August 2010 Modified to only return closest match as WITHINSPHRAD_CLOSEST</span>
<span class="comments">;                   (importing some stuff back from MATCH_2D)</span>
<span class="comments">;    8 Sept 2010    Renamed MATCH_SPH. Added /ONE_TO_ONE option, and modified</span>
<span class="comments">;                   to explicitly call MATCHALL_SPH and then cull.</span>
<span class="comments">;    9 Feb 2011     Forked as MATCH_ND to handle Euclidean case of arbitrary dimension.</span>
<span class="comments">;    13 April 2011  Fixed to work around cumulative total 1-element array bug.</span>
<span class="comments">;-</span>
<a id="match_nd:source"></a>function match_nd, p1, p2, maxdistance, mindist=mindist, one_to_one=one2onep

if (size(maxdistance))[0] ne 0 then message, 'MaxDistance must be a scalar.'
p1size = size(p1,/dimen)
p2size = size(p2,/dimen)
if n_elements(p1size) ne 2 then $
  message, 'P1 must be an N1xD dimensional array.'
if n_elements(p2size) ne 2 then $
  message, 'P2 must be an N2xD dimensional array.'
if p1size[1] ne p2size[1] then $
  message, 'P1 and P2 must have the same number of dimensions.'

ndimen = p1size[1]
n1 = p1size[0]
n2 = p2size[0]

<span class="comments">; get all matches within maxdistance</span>
matches = matchall_nd(p1, p2, maxdistance, nwithin, distance=distance)

<span class="comments">; if there are no matches, just quit</span>
if total(nwithin) eq 0 then return, replicate(-1L, n1)

<span class="comments">; sort all by distance</span>
<span class="comments">; create unique distance by adding the maximum distance times i1 to each</span>
<span class="comments">; entry corresponding to i1:</span>
<span class="comments">; first use histogram magic to create a list of which entry in 1 each</span>
<span class="comments">; match corresponds to</span>
<span class="comments">; note: using [] around cumulative total to deal with 1-element array bug</span>
hchunk = histogram([total(nwithin,/cumul,/int)]-1, min=0, reverse_indices=chunkri)
index1 = chunkri[0:n_elements(hchunk)-1]-chunkri[0] + (nwithin[0] eq 0)
<span class="comments">; now create unique distance by adding max(distance) * index1:</span>
uniqdist = distance + 1.1*max(distance)*index1
<span class="comments">; and sort</span>
sortdist = sort(uniqdist)
distance = distance[sortdist]
matches[n1+1] = (matches[n1+1:*])[sortdist]

matchloc = matches[0:n1-1]   <span class="comments">; starting point for each entry in list 1</span>
nomatchp = nwithin eq 0      <span class="comments">; 1 for entries with no match in sphrad</span>

<span class="comments">; iterate checking for multiple matches</span>
nincrements = lonarr(n1)
repeat begin
  nomatch = where(nomatchp, nnomatch)
  minpos = matches[matchloc]
  mindist = distance[matchloc - matches[0]]
  if nnomatch gt 0 then begin
    minpos[nomatch] = -1
    mindist[nomatch] = 0.
  endif
  <span class="comments">; if many-to-one matches allowed, no need to do anything else</span>
  if ~keyword_set(one2onep) then break  

  <span class="comments">; histogram of entries in list 2</span>
  h = histogram(minpos, min=0, max=n2-1, reverse_indices=ri)
  <span class="comments">; we're done if there are no multiple matches</span>
  if max(h) le 1 then break

  <span class="comments">; find entries with multiple matches and increment the non-closest</span>
  <span class="comments">; matches</span>
<span class="comments">; slower loop version:</span>
<span class="comments">;  multimatch = where(h gt 1, nmultimatch)</span>
<span class="comments">;  for mi=0l,nmultimatch-1 do begin</span>
<span class="comments">;    ; sort the distances associated with this entry</span>
<span class="comments">;    this2 = ri[ri[multimatch[mi]]:ri[multimatch[mi]+1]-1]</span>
<span class="comments">;    sortdist = sort(distance[matchloc[this2] - matches[0]])</span>
<span class="comments">;    notclosest = this2[sortdist[1:*]]</span>
<span class="comments">;    matchloc[notclosest]++</span>
<span class="comments">;    nincrements[notclosest]++</span>
<span class="comments">;  endfor</span>
<span class="comments">; faster histogram-of-histogram version:</span>
  h2 = histogram(h, min=2, omax=hmax, reverse_indices=ri2)
  nh2 = n_elements(h2)
  for repci=0l,nh2-1 do if h2[repci] gt 0 then begin
    targ = [h2[repci], repci+2]
    vec_inds = ri2[ri2[repci]:ri2[repci+1]-1]  <span class="comments">; indices into h</span>
    these1 = ri[rebin(ri[vec_inds], targ, /sample) + $
      rebin(transpose(lindgen(repci+2)), targ, /sample)]
    these2 = rebin(vec_inds, targ, /sample)
    <span class="comments">; now sort the distances for each entry in these2</span>
    sortdist = sort_nd(distance[matchloc[these1]-matches[0]], 2)
    notclosest = these1[sortdist[*,1:*]]
    matchloc[notclosest]++
    nincrements[notclosest]++    
  endif

  <span class="comments">; if we've gone past the end of the points within sphrad, mark it as a nomatch</span>
  nomatchp or= nincrements ge nwithin
endrep until 0 ne 0

return, minpos

end

</code>
    </div>
  </body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:40 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>readdolphot.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="readdolphot.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;        READDOLPHOT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;        Read the output of the DOLPHOT photometry package into easier-to-</span>
<span class="comments">;        use data structures.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;        Astro</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;        Result = READDOLPHOT(Filename, Nimg)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;        Filename:      Name of DOLPHOT output file</span>
<span class="comments">;</span>
<span class="comments">;        Nimg:          Number of images</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;        NHSTFILTERS:   If this is set to a number greater than 0, the output</span>
<span class="comments">;                       is assumed to have been generated using DOLPHOT/ACS</span>
<span class="comments">;                       or DOLPHOT/WFC3, and to have NHSTFILTERS photometry</span>
<span class="comments">;                       blocks at the beginning that give the combined results</span>
<span class="comments">;                       of each filter. The output is also assumed to both</span>
<span class="comments">;                       have instrumental and transformed magnitudes.</span>
<span class="comments">;</span>
<span class="comments">;        V2:            If /V2 set, then read in DOLPHOT 2 output (slightly changed</span>
<span class="comments">;                       from version 1)</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;        This function outputs an array of structures, one for each star.</span>
<span class="comments">;        The structure has the following fields:</span>
<span class="comments">;           extension, chip, xpos, ypos, chi, sn, sharpness, roundness,</span>
<span class="comments">;           majoraxis, crowding, objtype, counts[N], background[N],</span>
<span class="comments">;           magnitude[N], magerr[N], imgchi[N], imgsn[N], imgsharpness[N],</span>
<span class="comments">;           imgroundness[N], imgcrowding[N], fwhm[N], ellipticity[N],</span>
<span class="comments">;           PSFa[N], PSFb[N], PSFc[N], errflag[N].</span>
<span class="comments">;         If NHSTFILTERS gt 0 then magnitude[N] is replaced by instmag[N]</span>
<span class="comments">;         and transfmag[N].</span>
<span class="comments">;         If /V2 is set, then fwhm[N], ellipticity[N], PSFa[N],</span>
<span class="comments">;         PSFb[N] and PSFc[N] are replaced with ctcorr[N] and dctcorr[N].</span>
<span class="comments">;         N is Nimg plus NHSTFILTERS. The HST filter information comes</span>
<span class="comments">;         first.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;         Written by:     Jeremy Bailin</span>
<span class="comments">;         13 May 2010     Initial writing</span>
<span class="comments">;         18 June 2011    Updated to allow DOLPHOT2 output</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="readdolphot:source"></a>function readdolphot, filename, nimg, nhstfilters=nhstfilters, v2=v2output

if n_elements(nhstfilters) eq 0 then nhstfilters=0
if nhstfilters lt 0 then message, 'NHSTFILTERS must be greater than or equal to 0.'

hstphot = nhstfilters gt 0   <span class="comments">; 1 if in HST mode, 0 otherwise</span>
nctcorr = keyword_set(v2output) * 2   <span class="comments">; number of ctcorr columns: 2 if /V2, 0 otherwise</span>
nfepsf = 5 * (1-keyword_set(v2output))  <span class="comments">; number of fwhm/ellip/psf columns: 0 if /V2, 5 otherwise</span>

nhead = 11
nphot = 15 + hstphot  <span class="comments">; there's one extra field if in HST mode</span>
if keyword_set(v2output) then nphot -= 3   <span class="comments">; 5 fields gone, 2 new fields</span>
nblock = Nimg + nhstfilters

<span class="comments">; set up structure</span>
outstruct = {extension:0, chip:0, xpos:0., ypos:0., chi:0., sn:0., $
  sharpness:0., roundness:0., majoraxis:0, crowding:0., objtype:0, $
  counts:replicate(0.,nblock), background:replicate(0.,nblock), $
  magerr:replicate(0.,nblock), imgchi:replicate(0.,nblock), $
  imgsn:replicate(0.,nblock), imgsharpness:replicate(0.,nblock), $
  imgroundness:replicate(0.,nblock), imgcrowding:replicate(0.,nblock), $
  errflag:replicate(0,nblock)}
if hstphot then $
  outstruct = create_struct(outstruct, 'instmag',replicate(0.,nblock), $
    'transfmag',replicate(0.,nblock)) $
else $
  outstruct = create_struct(outstruct, 'magnitude',replicate(0.,nblock))
if keyword_set(v2output) then $
  outstruct = create_struct(outstruct, 'ctcorr',replicate(0.,nblock), $
    'dctcorr',replicate(0.,nblock)) $
else $
  outstruct = create_struct(outstruct, 'fwhm',replicate(0.,nblock), $
    'ellipticity',replicate(0.,nblock), 'PSFa',replicate(0.,nblock), $
    'PSFb',replicate(0.,nblock), 'PSFc',replicate(0.,nblock))

ncolumn = nhead + nblock * nphot
nrow = file_lines(filename)

<span class="comments">; generate final structure and a matrix to readf into</span>
struct = replicate(outstruct, nrow)
inmatrix = fltarr(ncolumn,nrow)

<span class="comments">; open file and read into matrix</span>
openr,lun,filename, /get_lun
readf,lun,inmatrix
close,lun
free_lun, lun

<span class="comments">; put elements into structure</span>
struct.extension = reform(inmatrix[0,*],nrow)
struct.chip = reform(inmatrix[1,*],nrow)
struct.xpos = reform(inmatrix[2,*],nrow)
struct.ypos = reform(inmatrix[3,*],nrow)
struct.chi = reform(inmatrix[4,*],nrow)
struct.sn = reform(inmatrix[5,*],nrow)
struct.sharpness = reform(inmatrix[6,*],nrow)
struct.roundness = reform(inmatrix[7,*],nrow)
struct.majoraxis = reform(inmatrix[8,*],nrow)
struct.crowding = reform(inmatrix[9,*],nrow)
struct.objtype = reform(inmatrix[10,*],nrow)
<span class="comments">; get an array of indices to the beginning of each photometry block</span>
blockpts = lindgen(nblock)*nphot + nhead
struct.counts = inmatrix[blockpts,*]
struct.background = inmatrix[blockpts+1,*]
if keyword_set(v2output) then begin
  struct.ctcorr = inmatrix[blockpts+2,*]
  struct.dctcorr = inmatrix[blockpts+3,*]
endif
if hstphot then begin
  struct.instmag = inmatrix[blockpts+2+nctcorr,*]
  struct.transfmag = inmatrix[blockpts+3+nctcorr,*]
endif else struct.magnitude = inmatrix[blockpts+2+nctcorr,*]
struct.magerr = inmatrix[blockpts+3+nctcorr+hstphot,*]
struct.imgchi = inmatrix[blockpts+4+nctcorr+hstphot,*]
struct.imgsn = inmatrix[blockpts+5+nctcorr+hstphot,*]
struct.imgsharpness = inmatrix[blockpts+6+nctcorr+hstphot,*]
struct.imgroundness = inmatrix[blockpts+7+nctcorr+hstphot,*]
struct.imgcrowding = inmatrix[blockpts+8+nctcorr+hstphot,*]
if not keyword_set(v2output) then begin
  struct.fwhm = inmatrix[blockpts+9+nctcorr+hstphot,*]
  struct.ellipticity = inmatrix[blockpts+10+nctcorr+hstphot,*]
  struct.PSFa = inmatrix[blockpts+11+nctcorr+hstphot,*]
  struct.PSFb = inmatrix[blockpts+12+nctcorr+hstphot,*]
  struct.PSFc = inmatrix[blockpts+13+nctcorr+hstphot,*]
endif
struct.errflag = inmatrix[blockpts+9+nctcorr+hstphot+nfepsf,*]

return, struct

end

</code>
    </div>
  </body>
</html>
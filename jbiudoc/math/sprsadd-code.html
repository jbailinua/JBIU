<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:43 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>sprsadd.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="sprsadd.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    SPRSADD</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Adds two sparse matrices (as generated by SPRSIN).</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Math</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    Result = SPRSADD(A,B)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    A:   Sparse matrix to be added.</span>
<span class="comments">;    B:   Sparse matrix to be added.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;    The addition of the matrices, in sparse format. This is functionally</span>
<span class="comments">;    equivalent to:</span>
<span class="comments">;      SPRSIN(FULSTR(A) + FULSTR(B))</span>
<span class="comments">;    but can be used even when the full matrices take up too much memory</span>
<span class="comments">;    for that operation.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;    IDL> a = sprsin([[1,0,0],[0,1,0],[0,0,1]])</span>
<span class="comments">;    IDL> b = sprsin([[0,0,2],[0,2,0],[2,0,0]])</span>
<span class="comments">;    IDL> c = sprsadd(a,b)</span>
<span class="comments">;    IDL> print, fulstr(c)</span>
<span class="comments">;          1.00000      0.00000      2.00000</span>
<span class="comments">;          0.00000      3.00000      0.00000</span>
<span class="comments">;          2.00000      0.00000      1.00000</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;    Written by:   Jeremy Bailin, November 2008</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="sprsadd:source"></a>function sprsadd, a, b

<span class="comments">; what is the size of the matrix?</span>
N = a.ija[0]-2
if b.ija[0]-2 ne N then message, 'SPRSADD: A and B must have the same size.'

<span class="comments">; figure out the full indices of all specified elements</span>
a_i = lonarr(n_elements(a.sa)-1)
b_i = lonarr(n_elements(b.sa)-1)
<span class="comments">; diagonal elements</span>
a_i[0] = lindgen(N)*N+lindgen(N)
b_i[0] = lindgen(N)*N+lindgen(N)
an=N & bn=N
for i=0l,N-1 do begin  <span class="comments">; loop through rows</span>
  a_non0 = a.ija[i+1]-a.ija[i]
  b_non0 = b.ija[i+1]-b.ija[i]
  if a_non0 gt 0 then a_i[an] = i*N + a.ija[a.ija[i:i+a_non0-1]-1]-1
  an += a_non0
  if b_non0 gt 0 then b_i[bn] = i*N + b.ija[b.ija[i:i+b_non0-1]-1]-1
  bn += b_non0
endfor

all_index = [a_i,b_i]
if n_elements(a.sa) eq N+1 then a_vals = a.sa[0:N-1] $
  else a_vals = [a.sa[0:N-1],a.sa[N+1:*]]
if n_elements(b.sa) eq N+1 then b_vals = b.sa[0:N-1] $
  else b_vals = [b.sa[0:N-1],b.sa[N+1:*]]
all_vals = [a_vals,b_vals]
indexsort = sort(all_index)
indexuniq = uniq(all_index[indexsort])
dupes = where(indexuniq-[-1,indexuniq] gt 1, comp=single, $
  ncomp=nsingle)
<span class="comments">; we know there are at least N dupes because the diagonals are</span>
<span class="comments">; always represented, so we don't need to test the where</span>
combined_index = all_index[indexsort[indexuniq[dupes]]]
combined_vals = all_vals[indexsort[indexuniq[dupes]]]+all_vals[indexsort[indexuniq[dupes]-1]]
if nsingle gt 0 then begin
  combined_index = [combined_index, all_index[indexsort[indexuniq[single]]]]
  combined_vals = [combined_vals, all_vals[indexsort[indexuniq[single]]]]
endif

<span class="comments">; create the output array using SPRSIN in col, row, val form</span>
return, sprsin(combined_index mod N, combined_index/N, combined_vals, N)
end

</code>
    </div>
  </body>
</html>
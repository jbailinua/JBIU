<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:43 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ml_distfit.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ml_distfit.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">
forward_function ml_nnl, hessian, derivee2xy, ml_distfit

<a id="ML_NNL:source"></a>function ML_NNL, P
common ML_DISTFIT_CB, DATA, FN, CONSTRAINTP, CONSTRAINTFUNC
  bignum=1e10
  <span class="comments">; if we're in a constrained part of parameter space, get the hell out!</span>
  if constraintp then if ~call_function(constraintfunc,p) then return, bignum

  f = call_function(fn,data,p)
  <span class="comments">; if there are any negative values, get out of there.</span>
  if total(f lt 0.) gt 0 then return, bignum

  <span class="comments">; don't include zeros</span>
  nonzero = where(f ne 0.0,nok)
  if nok gt 0 then nnl=-total(alog(f[nonzero])) else nnl=bignum

  return, nnl
end


<span class="comments">; uses derivee2xy to calculate partial derivatives, then inverts</span>
<span class="comments">; (based on MLEfit.pro)</span>
<a id="hessian:source"></a>pro hessian, name, param, correl
<span class="comments">; compute the matrix elements</span>
	Ndim=N_elements(param)
	temp=dblarr(Ndim,Ndim)
	for i=0,Ndim-1 do begin
		for j=i,Ndim-1 do begin
			temp[i,j]=derivee2xy(name,param,i,j)
			temp[j,i]=temp[i,j]
		endfor
	endfor
	correl=invert(temp)
end


<span class="comments">; calculate partial derivatives</span>
<span class="comments">; (based on MLEfit.pro, but with the brackets fixed up so it's readable)</span>
<a id="derivee2xy:source"></a>function derivee2xy, name, xparam, nx, ny
common ML_DISTFIT_CB, DATA, FN, CONSTRAINTP, CONSTRAINTFUNC

	temp=xparam
<span class="comments">;</span>
	if (nx EQ ny) then begin
<span class="comments">;</span>
<span class="comments">; 2nd derivative with respect to the same nx-ieme</span>
<span class="comments">; variable</span>
<span class="comments">;</span>
		h=abs(xparam[nx]*0.001d0)
		if (h LT 0.01) then begin
			h=0.01d0
		endif
<span class="comments">;</span>
		f00=call_function(name,temp)
<span class="comments">;</span>
		temp[nx]=xparam[nx]+h
		fp10=call_function(name,temp)
<span class="comments">;</span>
		temp[nx]=xparam[nx]-h
		fm10=call_function(name,temp)
<span class="comments">;</span>
		return,(fp10+fm10-2.d0*f00)/h^2

	endif else begin

<span class="comments">;</span>
<span class="comments">; 2nd partial derivative with respect to the different</span>
<span class="comments">; variables</span>

		hx=abs(xparam[nx]*0.001d0)
		hy=abs(xparam[ny]*0.001d0)
		if (hx LT 0.01) then begin
			hx=0.01d0
		endif
		if (hy LT 0.01) then begin
			hy=0.01d0
		endif
<span class="comments">;</span>
		temp[nx]=xparam[nx]+hx
		temp[ny]=xparam[ny]+hy
		fp1p1=call_function(name,temp)
<span class="comments">;</span>
		temp[nx]=xparam[nx]+hx
		temp[ny]=xparam[ny]-hy
		fp1m1=call_function(name,temp)
<span class="comments">;</span>
		temp[nx]=xparam[nx]-hx
		temp[ny]=xparam[ny]+hy
		fm1p1=call_function(name,temp)
<span class="comments">;</span>
		temp[nx]=xparam[nx]-hx
		temp[ny]=xparam[ny]-hy
		fm1m1=call_function(name,temp)

		return,(fp1p1+fm1m1-fp1m1-fm1p1)/4.d0/hx/hy
	endelse

end



<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;    ML_DISTFIT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Performs maximum likelihood fitting of a distribution.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Math</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    ML_DISTFIT, X, Parm, Function_Name, ConfRegion</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    X:              Array of input data values. This is passed straight to the</span>
<span class="comments">;                    user-supplied function, so complicated data structures that</span>
<span class="comments">;                    encompass multi-dimensional information for each data</span>
<span class="comments">;                    point can be used.</span>
<span class="comments">;</span>
<span class="comments">;    Parm:           Variable containing initial guesses for parameters on input</span>
<span class="comments">;                    and best fit values on output.</span>
<span class="comments">;</span>
<span class="comments">;    Function_Name:  Name of user-supplied function defining the distribution.</span>
<span class="comments">;                    The function must accept 2 arguments, X and Parm, and</span>
<span class="comments">;                    return a vector containing the likelihood values for</span>
<span class="comments">;                    each data point in X for the point in parameter space</span>
<span class="comments">;                    given by Parm. The likelihood must be normalized so</span>
<span class="comments">;                    that its total integral over all possible values of X</span>
<span class="comments">;                    is a constant, regardless of Parm (it makes the most</span>
<span class="comments">;                    sense to normalize this integral to unity, but that</span>
<span class="comments">;                    is not strictly required).</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;    ConfRegion:     Lower and upper error estimates of each parameter,</span>
<span class="comments">;                    marginalized over the other parameters.</span>
<span class="comments">;                    I.e. ConfRegion[*,0] returns [low0,high0]</span>
<span class="comments">;                    where low0 &lt;= parm[0] &lt;= high0</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;    FITA:           Vector of which parameters should be fit (1 for each</span>
<span class="comments">;                    parameter to be fit, 0 for each parameter to be held</span>
<span class="comments">;                    constant).</span>
<span class="comments">;                    THERE IS A BUG IN THE IMPLEMENTATION. DO NOT USE.</span>
<span class="comments">;</span>
<span class="comments">;    CONSTRAINT:     Name of a user-supplied function that takes a parameter</span>
<span class="comments">;                    vector as input and returns 1 if the point in parameter</span>
<span class="comments">;                    space is permitted and 0 if it is not permitted.</span>
<span class="comments">;</span>
<span class="comments">;    LIKELIHOOD:     Outputs an M-dimensional array with the likelihood</span>
<span class="comments">;                    values over the range of parameter space probed. M is</span>
<span class="comments">;                    the number of parameters that are fitted, which can be</span>
<span class="comments">;                    less than the length of Parm if FITA is used.</span>
<span class="comments">;</span>
<span class="comments">;    LIKERANGE:      2xM dimensional array containing the bounds of the</span>
<span class="comments">;                    LIKELIHOOD array.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;    Fit the width and offset of a zero-centered Gaussian plus constant</span>
<span class="comments">;    distribution.</span>
<span class="comments">;</span>
<span class="comments">;    First, define the distribution function:</span>
<span class="comments">;    FUNCTION gauss_plus_const, X, Parm</span>
<span class="comments">;      ; Parm[0]=constant offset, Parm[1]=width sigma</span>
<span class="comments">;      vmax = 2000.</span>
<span class="comments">;      normalization = Parm[1]*SQRT(!pi/2.)*ERF(vmax/(SQRT(2.)*Parm[1])) $</span>
<span class="comments">;        + vmax*Parm[0]</span>
<span class="comments">;      distribution = EXP(-X^2/(2.*Parm[1]^2)) + Parm[0]</span>
<span class="comments">;      RETURN, distribution/normalization</span>
<span class="comments">;    END</span>
<span class="comments">;</span>
<span class="comments">;    Then generate some data that should adhere to this distribution,</span>
<span class="comments">;    with a width of 250 and a constant term containing 10% of the points.</span>
<span class="comments">;    IDL> data = [250*RANDOMN(seed, 900), 4000*(RANDOMU(seed, 100) - 0.5)]</span>
<span class="comments">;</span>
<span class="comments">;    And finally fit the distribution:</span>
<span class="comments">;    IDL> parm = [0., 100.]</span>
<span class="comments">;    IDL> ML_DISTFIT, data, parm, 'gauss_plus_const', parmconf</span>
<span class="comments">;    IDL> PRINT, parm</span>
<span class="comments">;         0.0625345         223.94577</span>
<span class="comments">;    IDL> PRINT, parmconf</span>
<span class="comments">;        0.057511609  0.0973332</span>
<span class="comments">;          207.087      243.841</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Written by: Jeremy Bailin. Thanks to the writers of MLEfit.pro, which</span>
<span class="comments">;                 furnished the Hessian routines, Peder Norberg for useful</span>
<span class="comments">;                 discussions, and Nicolas Petitclerc for additional testing.</span>
<span class="comments">;     27 Nov 2008 Release in JBIU.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="ML_DISTFIT:source"></a>pro ML_DISTFIT, X, Parm, Function_Name, ConfRegion, FITA=FITA, $
   LIKELIHOOD=LIKELIHOOD, LIKERANGE=LIKERANGE, CONSTRAINT=CONSTRAINT
common ML_DISTFIT_CB, DATA, FN, CONSTRAINTP, CONSTRAINTFUNC


ftol=1e-8
minfracerr=0.01
maxit=20
nptsperparmside=30

data=x
fn=function_name
nparm = (size(parm,/dimen))[0]

if n_elements(constraintfunc) eq 0 then constraintp=0 else begin
  constraintp=1
  constraintfunc=constraint
endelse

if n_elements(fita) gt 0 then begin
  if n_elements(fita) ne nparm then message, 'FITA and PARM must have the same number of elements'
endif else begin
  fita=replicate(1.0,nparm)
endelse
whichfitparms = where(fita ne 0, complement=whichconstparms, nfitparms, $
  ncomp=nconstparms)
if nfitparms gt 0 then begin   <span class="comments">; don't bother if we're not fitting anything</span>

identmatrix=identity(nparm,/double)
<span class="comments">; note that if nparm=1, this doesn't appear square to Powell</span>
powell, parm, reform(identmatrix,nparm,nparm), ftol, fmin, 'ML_NNL', /DOUBLE
min_likelihood = ml_nnl(parm)

<span class="comments">; initial estimate of confidence limits using covariance matrix</span>
hessian, 'ML_NNL', parm, covar
sigma = sqrt(covar[indgen(nparm),indgen(nparm)])

<span class="comments">; now do it for real using the full likelihood</span>
<span class="comments">; only do it for parameters that we're actually fitting</span>
nsigslow = replicate(3.0,nfitparms)
nsigshigh = replicate(3.0,nfitparms)
likelihood=dblarr(replicate(2*nptsperparmside+1,nfitparms))
<span class="comments">; if there are any that are ridiculously small sigmas, set them to minfracerr</span>
lowsig = where((sigma lt minfracerr*parm) or (sigma ne sigma), ntoolow)
if ntoolow gt 0 then sigma[lowsig] = (minfracerr*parm)[lowsig]
incrementslow = replicate(1B,nfitparms) & ninclow=nfitparms
incrementshigh = replicate(1B,nfitparms) & ninchigh=nfitparms
for sigi=1,maxit do begin
  lowrange = parm[whichfitparms] - sigma[whichfitparms]*nsigslow
  highrange = parm[whichfitparms] + sigma[whichfitparms]*nsigshigh
  deltaparmlow = nsigslow*sigma[whichfitparms]/nptsperparmside
  deltaparmhigh = nsigshigh*sigma[whichfitparms]/nptsperparmside
  indexmap = dblarr(nfitparms,2*nptsperparmside+1)
  indexmap[*,0:nptsperparmside]=rebin(lowrange,nfitparms,nptsperparmside+1) + $
    deltaparmlow#findgen(nptsperparmside+1)
  indexmap[*,nptsperparmside:*]=rebin(parm[whichfitparms],nfitparms,nptsperparmside+1) $
    + deltaparmhigh#findgen(nptsperparmside+1)
  likerange = [[lowrange],[highrange]]
  for i=0L,n_elements(likelihood)-1 do begin
    likind = array_indices(likelihood,i)
    <span class="comments">; don't bother recalculating sections of the likelihood array</span>
    <span class="comments">; that haven't changed</span>
    skipcalc=1
    if (ninclow gt 0) then begin
      if total((likind le nptsperparmside)[incrementslow]) ne 0 then skipcalc=0
    endif
    if (ninchigh gt 0) then begin
      if total((likind ge nptsperparmside)[incrementshigh]) ne 0 then skipcalc=0
    endif
    if skipcalc then continue
    ptest = parm
    ptest[whichfitparms] = indexmap[lindgen(nfitparms),likind]
    likelihood[i] = ml_nnl(ptest)
  endfor

  xi21 = where(likelihood le min_likelihood+1.0)
  xi21_ind = reform(array_indices(likelihood,xi21),nfitparms,n_elements(xi21))

  confregion = fltarr(2,nparm)
  minmaxinds = minmax(xi21_ind, dimen=2)
  confregion[0,whichfitparms] = transpose(indexmap[lindgen(nfitparms),minmaxinds[0,*]])
  confregion[1,whichfitparms] = transpose(indexmap[lindgen(nfitparms),minmaxinds[1,*]])

  <span class="comments">; if we haven't reached the edge of the confidence region in a given</span>
  <span class="comments">; parameter, expand the range we're looking at</span>
  incrementslow = where(confregion[0,whichfitparms] le indexmap[*,0], ninclow, $
    complement=noinclow)
  if ninclow gt 0 then nsigslow[incrementslow] *= 3.0
  incrementshigh = where(confregion[1,whichfitparms] ge indexmap[*,2*nptsperparmside], $
     ninchigh, complement=noinchigh)
  if ninchigh gt 0 then nsigshigh[incrementshigh] *= 3.0
  if ninclow+ninchigh eq 0 then break
endfor

if sigi ge maxit then print, 'ML_DISTFIT: Maximum number of iterations reached. Errors are probably underestimated.' 

end <span class="comments">;if there are fit parameters</span>

<span class="comments">; the confidence region of a constant parameter is just the value given</span>
if nconstparms gt 0 then $
  confregion[*,whichconstparms] = rebin(transpose(parm[whichconstparms]), $
  2,nconstparms)

end


</code>
    </div>
  </body>
</html>
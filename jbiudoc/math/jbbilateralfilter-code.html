<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:42 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>jbbilateralfilter.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="jbbilateralfilter.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    JBBILATERALFILTER</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Implements the bilateral filter on an image.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Math</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   Result = JBBILATERALFILTER(Image, Sigma_Space, Sigma_Range)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;   Image:        2D array to be filtered.</span>
<span class="comments">;</span>
<span class="comments">;   Sigma_Space:  Gaussian width in the spatial dimensions.</span>
<span class="comments">;</span>
<span class="comments">;   Sigma_Range:  Gaussian width in the intensity dimension.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;   Uses the Paris & Durand (2006) algorithm. Note that there is heavy</span>
<span class="comments">;   memory optimization because the application it was written for runs</span>
<span class="comments">;   it on extremely large images.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Original release by Jeremy Bailin, 3 Dec 2012</span>
<span class="comments">;   Bug fixes (floating point locations for</span>
<span class="comments">;     trilinear interpolation, /edge_zero</span>
<span class="comments">;     instead of /edge_truncate) and improved documentation 4 Dec 2012</span>
<span class="comments">;   Added lots of TEMPORARY and SHRINKINTTYPE calls to improve memory usage   6 Dec 2012</span>
<span class="comments">;</span>
<span class="comments">;- </span>
<a id="jbbilateralfilter:source"></a>function jbbilateralfilter, image, sigma_space, sigma_range

<span class="comments">; Number of sigmas at which to truncate Gaussian. Should be an integer</span>
<span class="comments">; so that the number of elements in the kernel is an integer!</span>
truncate = 2

<span class="comments">; dimensions of original image and of downsampled image</span>
originalimagedimen = size(image, /dimen)
downimagedimen = ceil(originalimagedimen / float(sigma_space))

<span class="comments">; range of intensity values</span>
intensityrange = minmax(image)

<span class="comments">; "down" variables refer to downsampled versions</span>
downintensityrange = ceil( (intensityrange-intensityrange[0])/sigma_range )
intensitydimen=(downintensityrange[1]-downintensityrange[0])+1

<span class="comments">; dimensions of downsampled 3d arrays</span>
dimen3d = [downimagedimen,intensitydimen]
ndownimage = product(/int, downimagedimen)

<span class="comments">; calculated downsampled intensity, both the real value and a rounded integer</span>
<span class="comments">; to determine where in the 3D grid it goes</span>
downintensity = round( (image-intensityrange[0])/float(sigma_range) )
shrinkinttype, downintensity
<span class="comments">; calculated downsampled xy positions, both the real value and rounded integers</span>
<span class="comments">; to determine where in the 3D grid it goes</span>
downxy_float = array_indices(originalimagedimen, lindgen(originalimagedimen), /dimen) / $
  float(sigma_space)
downx = reform(round(downxy_float[0,*]))
shrinkinttype, downx
downy = reform(round(downxy_float[1,*]))
shrinkinttype, downy
<span class="comments">; construct a 1D index into the downsampled 3D array using the rounded integers</span>
indices3d = temporary(downx) + temporary(downy)*downimagedimen[0] + $
  temporary(downintensity)*ndownimage
shrinkinttype, indices3d

<span class="comments">; Note that the use of the "homogeneous vector" (wi,w) is not very well</span>
<span class="comments">; explained in the Paris & Durand papers. The easiest way to think about it</span>
<span class="comments">; is that the weights tell you how many full-resolution pixels get placed into</span>
<span class="comments">; each low-resolution grid spacing. This is initially an integer, but</span>
<span class="comments">; becomes a real floating point weight after convolution.</span>
downwi = fltarr(dimen3d)
downw = fltarr(dimen3d)
<span class="comments">; accumulate all of the wi's and w's in the downsampled 3D grid using the standard</span>
<span class="comments">; double histogram technique. see the drizzling/chunking page.</span>
h1 = histogram(indices3d, reverse_indices=ri1, omin=om)
shrinkinttype, ri1  <span class="comments">; not likely to help, but can't hurt</span>
h2 = histogram(h1, reverse_indices=ri2, min=1)
<span class="comments">; cases without duplication</span>
if h2[0] gt 0 then begin
  vec_inds = ri2[ri2[0]:ri2[1]-1]
  downw[om+vec_inds] = 1.
  downwi[om+vec_inds] = image[ri1[ri1[vec_inds]]]
endif
<span class="comments">; cases duplicated j+1 times (+1 because min=1 in the definition of h2)</span>
for j=1,n_elements(h2)-1 do if h2[j] gt 0 then begin
  vec_inds = ri2[ri2[j]:ri2[j+1]-1]  <span class="comments">; indices into h1</span>
  vinds = om + vec_inds
  shrinkinttype, vinds
  <span class="comments">; originals plus the following j values because we add lindgen(j+1)</span>
  vec_inds = rebin(ri1[vec_inds], h2[j], j+1, /sample) + $
    rebin(transpose(lindgen(j+1)), h2[j], j+1, /sample)
  shrinkinttype, vec_inds
  <span class="comments">; the weight by definition is j+1 because these indices were repeated j+1 times</span>
  downw[vinds] = j+1
  downwi[vinds] += total(image[ri1[vec_inds]], 2)
endif


<span class="comments">; convolve with the 3D Gaussian using CONVOL. Because the</span>
<span class="comments">; kernel is separable, we can do 3 separate 1D convolutions,</span>
<span class="comments">; which is much faster than via FFT because of the</span>
<span class="comments">; compactness of the kernel (when truncated).</span>
nkernel = 2*truncate+1
kernelaxis = findgen(nkernel)-truncate
kernel1d = exp(-0.5*kernelaxis^2.) / sqrt(2.*!pi)
<span class="comments">; convolve in each dimension in turn. The reforms turn the 1D kernel</span>
<span class="comments">; along each dimension.</span>
downwiconvol_1 = convol(temporary(downwi), reform(kernel1d,nkernel,1,1), /center, /edge_zero)
downwconvol_1 = convol(temporary(downw), reform(kernel1d,nkernel,1,1), /center, /edge_zero)
downwiconvol_2 = convol(temporary(downwiconvol_1), reform(kernel1d,1,nkernel,1), /center, /edge_zero)
downwconvol_2 = convol(temporary(downwconvol_1), reform(kernel1d,1,nkernel,1), /center, /edge_zero)
downwiconvol = convol(temporary(downwiconvol_2), reform(kernel1d,1,1,nkernel), /center, /edge_zero)
downwconvol = convol(temporary(downwconvol_2), reform(kernel1d,1,1,nkernel), /center, /edge_zero)


<span class="comments">; trilinearly interpolate downsampled functions</span>
downintensity_float = (image-intensityrange[0]) / float(sigma_range)
wi = interpolate(temporary(downwiconvol), downxy_float[0,*], downxy_float[1,*], downintensity_float)
w = interpolate(temporary(downwconvol), downxy_float[0,*], downxy_float[1,*], downintensity_float)

<span class="comments">; normalize result and restore image dimensions</span>
filteredintensity = reform(temporary(wi)/temporary(w), originalimagedimen)

return, filteredintensity
end

</code>
    </div>
  </body>
</html>
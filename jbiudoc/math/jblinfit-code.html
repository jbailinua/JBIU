<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.4 on Fri Jul 29 15:39:42 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>jblinfit.pro (Documentation for jbiu/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="jblinfit.pro (Documentation for jbiu/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    JBLINFIT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Performs least squares fitting to a straight line, but can perform it over</span>
<span class="comments">;    one particular dimension for a multi-dimensional data set. Acts like the</span>
<span class="comments">;    built-in function LINFIT if DIMENSION is not set.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;    Math</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    Result = JBLINFIT(X, Y)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    X:         Array containing the independent variable values.</span>
<span class="comments">;</span>
<span class="comments">;    Y:         Array containing the dependent variable values.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;    DIMENSION: If X and Y are multi-dimensional arrays, perform the fitting</span>
<span class="comments">;               accross this dimension.</span>
<span class="comments">;</span>
<span class="comments">;    CHISQR:    Output variable containing the chi squared values.</span>
<span class="comments">;</span>
<span class="comments">;    COVAR:     Output variable containing the covariance matrix.</span>
<span class="comments">;</span>
<span class="comments">;    MEASURE_ERRORS:  Array containing the measurement errors in Y.</span>
<span class="comments">;</span>
<span class="comments">;    PROB:      Output variable containing the probability of obtaining a fit</span>
<span class="comments">;               with at least this chi squared value.</span>
<span class="comments">;</span>
<span class="comments">;    SIGMA:     Output variable containing uncertainties in fit parameters.</span>
<span class="comments">;</span>
<span class="comments">;    YFIT:      Output variable containing the values of the dependent variable at</span>
<span class="comments">;               the X locations, according to the fit.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;    Returns the parameters of the linear fit. If X has dimensions [D1, D2, D3... DM],</span>
<span class="comments">;    and DIMENSION=N, then Result has dimensions [2, D1...DN-1, DN+1...DM].</span>
<span class="comments">;    Result[0,....] contains the constant term and Result[1,...] contains the slope.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;    seed = 43l</span>
<span class="comments">;    n = 10000L</span>
<span class="comments">;    x = 1e-3 * findgen(n)</span>
<span class="comments">;    y1 = x + randomn(seed, n)</span>
<span class="comments">;    y2 = 10. - 2 * x + 0.5 * randomn(seed, n)</span>
<span class="comments">;    x = [[x],[x]]</span>
<span class="comments">;    y = [[y1],[y2]]</span>
<span class="comments">;    </span>
<span class="comments">;    result = jblinfit(x, y, sigma=sigma, yfit=yfit, dimension=1)</span>
<span class="comments">;    </span>
<span class="comments">;    xax = [0,10]</span>
<span class="comments">;    cgplot, psym=3, x, y1, yrange=minmax(y), color='red'</span>
<span class="comments">;    cgplot, /overplot, psym=3, x, y2, color='blue'</span>
<span class="comments">;    cgplot, /overplot, xax, result[0,0] + result[1,0]*xax, color='red'</span>
<span class="comments">;    cgplot, /overplot, xax, result[0,1] + result[1,1]*xax, color='blue'</span>
<span class="comments">;    </span>
<span class="comments">;    cgtext, x[9000], yfit[9000,0] + 2, color='red', align=1, $</span>
<span class="comments">;      string(result[0,0], sigma[0,0], result[1,0], sigma[1,0], $</span>
<span class="comments">;      format='(%"y = (%0.2f +/- %0.2f) + (%0.3f +/- %0.3f) x")'), $</span>
<span class="comments">;      charsize=1.5</span>
<span class="comments">;    cgtext, x[9000], yfit[9000,1] - 3, color='blue', align=1, $</span>
<span class="comments">;      string(result[0,1], sigma[0,1], result[1,1], sigma[1,1], $</span>
<span class="comments">;      format='(%"y = (%0.2f +/- %0.2f) + (%0.3f +/- %0.3f) x")'), $</span>
<span class="comments">;      charsize=1.5</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;    Written by:   Jeremy Bailin</span>
<span class="comments">;    28 March 2011   Initial writing.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="jblinfit:source"></a>function jblinfit, x, y, dimension=dimension, chisqr=chisqr, covar=covar, $
  measure_errors=measure_errors, prob=prob, sigma=sigma, yfit=yfit

<span class="comments">; if not using dimension, just pass to LINFIT</span>
if ~keyword_set(dimension) then return, linfit(x, y, chisqr=chisqr, covar=covar, $
  measure_errors=measure_errors, prob=prob, sigma=sigma, yfit=yfit)

<span class="comments">; check dimensions of inputs</span>
insize_x = size(x, /dimen)
insize_y = size(y, /dimen)
insize_err = size(measure_errors, /dimen)
if n_elements(insize_x) ne n_elements(insize_y) or $
  total(/int, insize_x ne insize_y) gt 0 then message, 'X and Y must have same dimensions.'
if n_elements(measure_errors) gt 0 then $
  if n_elements(insize_x) ne n_elements(insize_err) or $
    total(/int, insize_x ne insize_err) gt 0 then message, 'MEASURE_ERRORS must have same dimensions as X and Y.'

ndata = insize_x[dimension-1]

<span class="comments">; use measure_errors=1 if not specified</span>
if n_elements(measure_errors) eq 0 then measure_errors = replicate(1., insize_y)
<span class="comments">; define 1 / sigma^2</span>
inverse_errsq = 1. / measure_errors^2

<span class="comments">; based on NR "Fitting Data to a Straight Line" section (15.2 in 2nd edition)</span>
S = total(inverse_errsq, dimension)
Sx = total(x * inverse_errsq, dimension)
Sy = total(y * inverse_errsq, dimension)
formsize = insize_x
formsize[dimension-1] = 1
tval = (x - rebin(reform(Sx/S, formsize), insize_x, /samp)) / measure_errors
Stt = total(tval^2, dimension)

fit_slope = total(tval * y / measure_errors, dimension) / Stt
fit_const = (Sy - Sx * fit_slope) / S
err_slope = sqrt(1. / Stt)
err_const = sqrt((1. + Sx^2 / (S * Stt)) / S)

outsize = size(fit_const, /dimen)
noutsize = product(outsize, /int)

result = [reform(fit_const,[1,outsize]), reform(fit_slope,[1,outsize])]
sigma = [reform(err_const,[1,outsize]), reform(err_slope,[1,outsize])]
<span class="comments">; apparently you can only nest 3 levels of [[[]]] and I would need 4 to</span>
<span class="comments">; do this elegantly:</span>
covab = - Sx / (S * Stt)
covar = fltarr(2,2, noutsize)
covar[0,0,*] = reform(err_const^2, 1, 1, noutsize)
covar[0,1,*] = reform(covab, 1, 1, noutsize)
covar[1,0,*] = reform(covab, 1, 1, noutsize)
covar[1,1,*] = reform(err_slope^2, 1, 1, noutsize)
covar = reform(covar, [2, 2, outsize])

yfit = rebin(reform(fit_const,formsize), insize_x, /samp) + $
  rebin(reform(fit_slope, formsize), insize_x, /samp) * x
chisqr = total( (y - yfit)^2 * inverse_errsq, dimension )
prob = 1. - igamma(0.5 * (ndata - 2), 0.5 * chisqr)

return, result

end

</code>
    </div>
  </body>
</html>
/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "Documentation for jbiu/";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("math/atanh.html", "atanh.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "atanh.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/atanh.html#atanh", "atanh", "routine in <a href="math/atanh.html">atanh.pro</a>", "atanh.pro", "", "atanh", "    Numerically calculate the inverse of the TANH function for real     values.   ", "x   Argument to atanh. May be an array.   ", "Math:", "    Written by: Jeremy Bailin     27 Nov 2008 Released in JBIU       IDL> PRINT, ATANH(TANH([0,1,2]))           0.00000      1.00000      2.00000     The arctanh of the argument. Note that because of the numerical inversion     method, the results will be inaccurate for input values very near 1.   ");
  
  

libdata[libdataItem++] = new Array("misc/augment_inherited_keyword.html", "augment_inherited_keyword.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "augment_inherited_keyword.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/augment_inherited_keyword.html#augment_inherited_keyword", "augment_inherited_keyword", "routine in <a href="misc/augment_inherited_keyword.html">augment_inherited_keyword.pro</a>", "augment_inherited_keyword.pro", "", "augment_inherited_keyword", "    Adds keywords to the _EXTRA structure.   ", "extra A structure of the form passed via the _EXTRA facility             inside a procedure or function. On output, contains             all old keywords (if any) plus the new Label=Value pair.   label String containing a new keyword to be added to Extra.   value Value to assign to the keyword.   ", "Misc", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU      PRO FUNNYPLOT, x, y, _EXTRA=extraplot       IF x[0] GT y[0] THEN AUGMENT_INHERITED_KEYWORD, extraplot, 'color', 2       PLOT, x, y, _EXTRA=extraplot     END ");
  
  

libdata[libdataItem++] = new Array("math/between.html", "between.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "between.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/between.html#between", "between", "routine in <a href="math/between.html">between.pro</a>", "between.pro", "", "between", "    Determines if the argument lies between the bounds.   ", "gtstrict Argument must be strictly greater than Lowerbound,                 rather than greater or equal to.   ltstrict Argument must be strictly less than Upperbound,                 rather than less or equal to.   lowerboundScalar or array of lower bounds.   argument  Scalar or array of numerical argument.   upperboundScalar or array of upper bounds.   ", "Math", "    Written by:    Jeremy Bailin     18 July 2009   Public release in JBIU      IDL> print, between(2.5, [0,1,2,3,4], 7.)        0   0   0   1   1     Outputs 1 for any element where Argument is between Lowerbound and     Upperbound, and 0 for all other elements. Values equal to Lowerbound     and Upperbound return 1 unless overridden by /GTSTRICT and/or /LTSTRICT.     Each of the inputs may be either a scalar or an array, but if more than     one are arrays then they must have the same numbers of elements.   ");
  
  

libdata[libdataItem++] = new Array("math/biharmonic_interp.html", "biharmonic_interp.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "biharmonic_interp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/biharmonic_interp.html#biharmonic_interp", "biharmonic_interp", "routine in <a href="math/biharmonic_interp.html">biharmonic_interp.pro</a>", "biharmonic_interp.pro", "", "biharmonic_interp", "    Performs biharmonic interpolation for a function defined on a 2D grid.       Biharmonic interplation of Z(X,Y) is equivalent to bilinear     interpolation on the grid Z( log(X), log(Y) ), which is in fact     how it is calculated.   ", "z    2D array containing the values of the function defined at each            X,Y grid point. The first dimension of Z must have the same length            as X and the second dimension must have the same length as Y.   x    Vector containing the x-locations of the grid points at which            the function is defined.   y    Vector containing the y-locations of the grid points at which            the function is defined.   xout A vector of x-locations at which the function is to be interpolated.   yout A vector of y-locations at which the function is to be interpolated.   ", "Math", "    Written by:   Jeremy Bailin     11 June 2008  Public release in JBIU      IDL> xgrid = [1.,2.]     IDL> ygrid = [2.,5.]     IDL> zvals = [ [10.,2.], [25.,15.] ]     IDL> PRINT, BIHARMONIC_INTERP(zvals, xgrid, ygrid, [1.3], [3.])           13.2745     A vector containing the value of the function biharmonically     interpreted at each Xout,Yout pair. The output will have the     same number of elements as Xout and Yout.   ");
  
  

libdata[libdataItem++] = new Array("math/bilin_interp.html", "bilin_interp.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "bilin_interp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/bilin_interp.html#bilin_interp", "bilin_interp", "routine in <a href="math/bilin_interp.html">bilin_interp.pro</a>", "bilin_interp.pro", "", "bilin_interp", "    Performs bilinear interpolation for a function defined on a 2D grid.   ", "z    2D array containing the values of the function defined at each            X,Y grid point. The first dimension of Z must have the same length            as X and the second dimension must have the same length as Y.   x    Vector containing the x-locations of the grid points at which            the function is defined.   y    Vector containing the y-locations of the grid points at which            the function is defined.   xout A vector of x-locations at which the function is to be interpolated.   yout A vector of y-locations at which the function is to be interpolated.   ", "Math", "    Written by:   Jeremy Bailin     11 June 2008  Public release in JBIU      IDL> xgrid = [1.,2.]     IDL> ygrid = [2.,5.]     IDL> zvals = [ [10.,2.], [25.,15.] ]     IDL> PRINT, BILIN_INTERP(zvals, xgrid, ygrid, [1.3], [3.])           12.4000     A vector containing the value of the function bilinearly     interpreted at each Xout,Yout pair. The output will have the     same number of elements as Xout and Yout.   ");
  
  

libdata[libdataItem++] = new Array("math/bootstrap_mean.html", "bootstrap_mean.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "bootstrap_mean.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/bootstrap_mean.html#bootstrap_mean", "bootstrap_mean", "routine in <a href="math/bootstrap_mean.html">bootstrap_mean.pro</a>", "bootstrap_mean.pro", "", "bootstrap_mean", "    Calculates the mean and a confidence limit on the mean based on     bootstrap resampling.   ", "nboot     Number of bootstrap resamplings. Default: 1000.   conflimit Confidence limit. Default: 0.68 (equivalent to 1sigma                 for a normal distribution).   uniqlist  If independent points are associated with more than one                 element of Values, then they should all be included or                 excluded together in the bootstrap resampling. In this                 case, set UNIQLIST to the result of running UNIQ on                 a list with the same length as Values containing the                 unique identifier associated with each. Note that for                 this to work, Values must be sorted in order of the                 identifier.   values A vector of values whose mean and error is to be calculated.   ", "Math", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU      Compares the expected error in the mean of normally-distributed values     to the bootstrap-determined error:      IDL> vals = RANDOMN(seed, 100)     IDL> vals = 2.5*RANDOMN(seed, 100)     IDL> PRINT, BOOTSTRAP_MEAN(vals)          -0.26419502    -0.014198994      0.22447498     IDL> PRINT, 2.5/SQRT(100)          0.250000     Returns a 3-element vector containing the lower limit, mean, and     upper limit.   ");
  
  

libdata[libdataItem++] = new Array("math/bootstrap_median.html", "bootstrap_median.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "bootstrap_median.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/bootstrap_median.html#bootstrap_median", "bootstrap_median", "routine in <a href="math/bootstrap_median.html">bootstrap_median.pro</a>", "bootstrap_median.pro", "", "bootstrap_median", "    Calculates the median and a confidence limit on the median based on     bootstrap resampling.   ", "nboot     Number of bootstrap resamplings. Default: 1000.   conflimit Confidence limit. Default: 0.68 (equivalent to 1sigma                 for a normal distribution).   uniqlist  If independent points are associated with more than one                 element of Values, then they should all be included or                 excluded together in the bootstrap resampling. In this                 case, set UNIQLIST to the result of running UNIQ on                 a list with the same length as Values containing the                 unique identifier associated with each. Note that for                 this to work, Values must be sorted in order of the                 identifier.   values A vector of values whose median and error is to be calculated.   ", "Math", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU      Calculates the error in the median of 5000 values distributed normally:      IDL> vals = 2.5*RANDOMN(seed,5000)     IDL> PRINT, BOOTSTRAP_MEDIAN(vals)          -0.25968859     -0.15505694     0.095240064     Returns a 3-element vector containing the lower limit, median, and     upper limit.   ");
  
  

libdata[libdataItem++] = new Array("math/combigen.html", "combigen.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "combigen.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/combigen.html#combigen", "combigen", "routine in <a href="math/combigen.html">combigen.pro</a>", "combigen.pro", "", "combigen", "    Generates all possible combinations n-choose-k.   ", "n   Maximum number.   k   Number of elements in each combination.   ", "Math", "    Written by Jeremy Bailin     1 April 2011   Initial writing.      Generate all combinations 5-choose-3:      IDL> print, combigen(5,3)            0       0       0       0       0       0       1       1       1       2            1       1       1       2       2       3       2       2       3       3            2       3       4       3       4       4       3       4       4       4     Returns a M x K array of all K-length combinations of numbers from 0 to N-1.   ");
  
  

libdata[libdataItem++] = new Array("misc/contourlevels.html", "contourlevels.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "contourlevels.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/contourlevels.html#contourlevels", "contourlevels", "routine in <a href="misc/contourlevels.html">contourlevels.pro</a>", "contourlevels.pro", "", "contourlevels", "    Calculates the contour level that encloses a given fraction of the data     in a multi-dimensional histogram.   ", "image        A histogram in arbitrary dimensions, e.g. as generated                    with HIST_2D or HIST_ND.   enclosedfrac The fraction of data points   ", "Misc", "    Takes an IMAGE generated using something like HIST_2D, ie. which     contains the number of data points that fall within the bounds of     each pixel, and calculates the contour levels that enclose a given     fraction ENCLOSEDFRAC (which can be an array) of the data points.     The RESULT can be passed to CONTOUR as the LEVELS= argument.     IMAGE may have any dimensionality desired.      Note that this errs on the side of lower contour levels that enclose     a larger fraction of the data. I.e. if no contour level contains exactly     ENCLOSEDFRAC of the data points then RESULT will be the highest contour     level that contains no less than ENCLOSEDFRAC of the data.   ");
  
  

libdata[libdataItem++] = new Array("plot/croppedtickmarks.html", "croppedtickmarks.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "croppedtickmarks.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/croppedtickmarks.html#croppedtickmarks", "croppedtickmarks", "routine in <a href="plot/croppedtickmarks.html">croppedtickmarks.pro</a>", "croppedtickmarks.pro", "", "croppedtickmarks", "    This function is used as a plug-in to YTICKFORMAT that     crops a number to the appropriate number of digits. For example,     logarithmic axes might have labels 0.001, 0.01, 0.1, 1, 10.   ", "axisindexvalue", "Plot", "    Written by:    Jeremy Bailin, based on Paul van Delst's logticks_exp.     12 June 2008   Public release in JBIU      x = [1,2,3,4]     y = [0.02,0.2,2,20]     PLOT, x, y, /YLOG, YTICKFORMAT='CROPPEDTICKMARKS' ");
  
  

libdata[libdataItem++] = new Array("math/dotp.html", "dotp.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "dotp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/dotp.html#dotp", "dotp", "routine in <a href="math/dotp.html">dotp.pro</a>", "dotp.pro", "", "dotp", "    Calculates the scalar product of two vectors.   ", "a  First vector.   b  Second vector.   ", "Math", "    Written by:  Jeremy Bailin     12 June 2008 Public release in JBIU      a = [1., -1.5, 2.]     b = [-3., -2., 1.5]     adotb = DOTP(a,b)     The scalar product of A and B.   ");
  
  

libdata[libdataItem++] = new Array("io/extract_rows.html", "extract_rows.pro", ".pro file in <a href="io/dir-overview.html">io/ directory</a>", "extract_rows.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("io/extract_rows.html#extract_rows", "extract_rows", "routine in <a href="io/extract_rows.html">extract_rows.pro</a>", "extract_rows.pro", "", "extract_rows", "    This function extracts rows from a CSV structure (as read     using READ_CSV) and returns a new CSV structure.   ", "a  A CSV structure, of the format read in using READ_CSV.   v  A vector of indices of the rows to extract.   ", "I/O", "    Written by:   Jeremy Bailin     11 June 2008  Public release in JBIU      A structure of the same form as the one returned by READ_CSV     containing only the rows listed in V.   ");
  
  

libdata[libdataItem++] = new Array("astro/force_newton.html", "force_newton.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "force_newton.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/force_newton.html#force_newton", "force_newton", "routine in <a href="astro/force_newton.html">force_newton.pro</a>", "force_newton.pro", "", "force_newton", "       Calculates the gravitational force from a particle distribution        at a list of positions.   ", "lengthunitLength unit, in cm (or kpc if /ASTRO is set). Default: 1kpc.   massunit  Mass unit, in grams (or solar masses if /ASTRO is                    set). Default: 1 solar mass.   astro     If /ASTRO is set then LENGTHUNIT and MASSUNIT are given                    in kpc and solar masses respectively, otherwise they are                    in CGS (Lengthunit in cm, Massunit in grams).   softening Plummer softening length. Default: 0 (no softening).   x    X coordinates at which to calculate forces.   y    Y coordinates at which to calculate forces.   z    Z coordinates at which to calculate forces.   xpartX coordinates of particle positions defining the mass               distribution.   ypartY coordinates of particle positions defining the mass               distribution.   zpartZ coordinates of particle positions defining the mass               distribution.   mass Mass of each particle.   ", "Astro", "       Written by:    Jeremy Bailin        10 June 2008   Public release in JBIU          Calculate the gravitational force on a line along the x-axis from        6 point masses placed at the vertices of a cube:         xmasspos = [-1,-1,-1,-1,1,1,1,1]        ymasspos = [-1,-1,1,1,-1,-1,1,1]        zmasspos = [-1,1,-1,1,-1,1,-1,1]        masses = REPLICATE(1.,8)        xlinepos = 0.1*FINDGEN(20)        ylinepos = REPLICATE(0.,20)        zlinepos = REPLICATE(0.,20)        forces = FORCE_NEWTON(xlinepos, ylinepos, zlinepos, xmasspos, ymasspos,          zmasspos, masses)        This function returns the gravitational force at each X,Y,Z position.        If there are NPOS positions, Result is an NPOSx3 matrix.   ");
  
  

libdata[libdataItem++] = new Array("plot/getpts.html", "getpts.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "getpts.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/getpts.html#getpts", "getpts", "routine in <a href="plot/getpts.html">getpts.pro</a>", "getpts.pro", "", "getpts", "    Find the locations of a number of points on an existing plot using CURSOR.     Use right mouse button to mark final point.   ", "device  Use device coordinates.   normal  Use normalized coordinates.   data    Use data coordinates (default).   verbose Print out each data point as it is selected.   _extrax    Array of x coordinates.   y    Array of y coordinates.   ", "Plot", "    Written by:   Jeremy Bailin, 3 December 2010   ");
  
  

libdata[libdataItem++] = new Array("plot/hist_nd_adaptive.html", "hist_nd_adaptive.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "hist_nd_adaptive.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/hist_nd_adaptive.html#hist_nd_adaptive", "hist_nd_adaptive", "routine in <a href="plot/hist_nd_adaptive.html">hist_nd_adaptive.pro</a>", "hist_nd_adaptive.pro", "", "hist_nd_adaptive", "    Given a list of particle positions (and optional particle weights), bin sizes, and ranges,     creates a density image where the regions with fewer particles are sampled at larger bin sizes.     This can be used as a drop-in for HIST_ND_WEIGHT, but it divides by the bin area (or ND-volume).   ", "min     ND-element array of minimum positions in final map. If a scalar, used for all dimensions.               Default is the minimum particle position in each dimension.   max     ND-element array of maximum positions in final map. If a scalar, used for all dimensions.               Default is the maximum particle position in each dimension.   weight  Array of weights for each particle.   levelmaxMaximum number of lower-density levels to use (0=no smoothing). Default: 4.   nthreshold  Minimum number of particles within a pixel before going to the next level. Default: 3.   v       An NDxN element array of the ND-dimensional positions of the N particles.   bin     Size of highest-resolution pixels in output image.   ", "Plot", "    Written by: Jeremy Bailin   20 June 2011       n = 100000     positions = 5*randomn(seed, 2, n)     image = hist_nd(positions, 0.5, min=-20, max=20) * 4     smthimage = hist_nd_adaptive(positions, 0.5, min=-20, max=20)     isurface, image, zrange=[0,3], title='Original'     isurface, smthimage, zrange=[0,3], title='Smooth'     Result contains a density map of the points. The map has its highest effective     resolution in the regions with the most points, but degrades to factor-of-2 lower resolutions     when the number of particles per pixel drops below the threshold.   ");
  
  

libdata[libdataItem++] = new Array("math/hist_nd_weight.html", "hist_nd_weight.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "hist_nd_weight.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/hist_nd_weight.html#hist_nd_weight", "hist_nd_weight", "routine in <a href="math/hist_nd_weight.html">hist_nd_weight.pro</a>", "hist_nd_weight.pro", "", "hist_nd_weight", "    Wrapper to the dfanning HIST_ND function that calculates a     weighted multi-dimensional histogram.   ", "weight      A vector of the same dimensions as V with the weights                   for each data value.   reverse_indices Outputs the reverse index array.   unweighted      Outputs the unweighted histogram.   _extra  All extra keywords are passed through to HIST_ND.   V  Values whose histogram is to be taken. V should be an NxP          array for P points in N dimensions.   BINBin size. May either be a scalar, or an N-dimensional vector.   ", "Math", "    Written by:     Jeremy Bailin     12 June 2008    Public release in JBIU     17 June 2011    Bug fix for bins with no entries.      IDL> q = TRANSPOSE( [ [0.1*FINDGEN(40)], [0.2*FINDGEN(40)] ] )     IDL> PRINT, HIST_ND_WEIGHT(q, 1, WEIGHT=q, UNWEIGHTED=plainhist)          0.500000      0.00000      0.00000      0.00000           2.50000      0.00000      0.00000      0.00000           0.00000      4.00000      0.00000      0.00000           0.00000      6.50000      0.00000      0.00000           0.00000      0.00000      7.50000      0.00000           0.00000      0.00000      10.5000      0.00000           0.00000      0.00000      0.00000      11.0000           0.00000      0.00000      0.00000      14.5000     IDL> PRINT, plainhist                5           0           0           0                5           0           0           0                0           5           0           0                0           5           0           0                0           0           5           0                0           0           5           0                0           0           0           5                0           0           0           5     The function returns a multi-dimensional histogram where each data value     has been weighted by its WEIGHT value. The return type is the same type     as WEIGHT.   ");
  
  

libdata[libdataItem++] = new Array("plot/histeq.html", "histeq.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "histeq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/histeq.html#histeq", "histeq", "routine in <a href="plot/histeq.html">histeq.pro</a>", "histeq.pro", "", "histeq", "    Performs histogram equalization scaling of a 2D image.   ", "zeroeq    Set this keyword to perform equalization using all pixels,                 even those with a value of zero. Default is to ignore pixels                 with a zero value.   mapping   Optional output keyword containing a 256-element array with the                 original values corresponding to each output value.   image     Input image (for example, as generated with HIST_2D) containing                 integer or byte values.   ", "Plot", "    Writen by:   Jeremy Bailin, 9 Dec 2008     Modified 12 Dec 2008    JB: Do not include zero values when performing                             eq unless /ZEROEQ is set.     Modified 26 Sept 2010   Adding MAPPING keyword.     17 June 2011        Efficiency improvement when input values                         are much greater than 1.       xpts = randomn(seed, 100000)     ypts = randomn(seed, 100000)     im1 = hist_2d(xpts,ypts,min1=-2,max1=2,bin1=0.05,min2=-2,max2=2,bin2=0.05)     im2 = histeq(im1)     im1 = bytscl(im1)     !p.multi = [0,2,2]     tvim, im1, xrange=[-2,2], yrange=[-2,2], title='Normal'     plothist, im1, title='Pixel values', bin=10     tvim, im2, xrange=[-2,2], yrange=[-2,2], title='Histogram-equalized'     plothist, im2, title='Pixel values', bin=10     !p.multi = 0     Result contains a byte-scaled image where the distribution of pixel values     is roughly uniform.   ");
  
  

libdata[libdataItem++] = new Array("math/histogram_weight.html", "histogram_weight.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "histogram_weight.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/histogram_weight.html#histogram_weight", "histogram_weight", "routine in <a href="math/histogram_weight.html">histogram_weight.pro</a>", "histogram_weight.pro", "", "histogram_weight", "    Wrapper to the built-in HISTOGRAM function that calculates a     weighted histogram.   ", "bin         Bin width. Passed through to HISTOGRAM.   weight      A vector of the same length as Data with the weights                   for each data value.   reverse_indices Outputs the reverse index array.   unweighted      Outputs the unweighted histogram.   _ref_extra  All extra keywords are passed through to HISTOGRAM.   DATA  Values whose histogram is to be taken.   ", "Math", "    Written by:     Jeremy Bailin     12 June 2008    Public release in JBIU     11 April 2009   Bug fix     8 November 2009 Bug fux for bins with no entries      IDL> values = 0.1*FINDGEN(40)     IDL> PRINT, HISTOGRAM_WEIGHT(values, WEIGHT=VALUES, UNWEIGHTED=plainhist)           4.50000      14.5000      24.5000      34.5000     IDL> PRINT, plainhist               10          10          10          10     The function returns a histogram where each Data value has been     weighted by its WEIGHT value. The return type is the same type     as WEIGHT.   ");
  
  

libdata[libdataItem++] = new Array("astro/inertiatens.html", "inertiatens.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "inertiatens.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/inertiatens.html#inertiatens", "inertiatens", "routine in <a href="astro/inertiatens.html">inertiatens.pro</a>", "inertiatens.pro", "", "inertiatens", "      Calculates the 2nd moment tensor (sometimes incorrectly referred to       as the moment of inertia tensor) of a mass distribution specified by       a list of particle positions.   ", "masses An N-element vector of the mass of each point. If not                specified, all masses are assumed to be unity.   r2weight If /R2WEIGHT is specified then particles are downweighted                  by a factor of 1/r^2 so that all particles have equal                  effect regardless of radius.   pos An Nx3 array specifying the 3d positions of the N particles             that make up the mass distribution.   ", "Astro", "      Written by:    Jeremy Bailin       10 June 2008   Public release in JBIU       22 July 2011   Bug fix for /R2WEIGHT to actually do something useful        Calculate the inertia tensor of 6 equal-mass points distributed on       the vertices of a cube:        xmasspos = [-1,-1,-1,-1,1,1,1,1]       ymasspos = [-1,-1,1,1,-1,-1,1,1]       zmasspos = [-1,1,-1,1,-1,1,-1,1]       itens = INERTIATENS([[xmasspos],[ymasspos],[zmasspos]])       The function returns a 3x3 symmetric array containing the 2nd moment       of the mass distribution tensor, i.e. Result[i,j] is the sum over each       particle k of MASSES[k] * Pos[k,i] * Pos[k,j].   ");
  
  

libdata[libdataItem++] = new Array("misc/is_sorted.html", "is_sorted.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "is_sorted.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/is_sorted.html#is_sorted", "is_sorted", "routine in <a href="misc/is_sorted.html">is_sorted.pro</a>", "is_sorted.pro", "", "is_sorted", "    Checks whether an array is already sorted.   ", "array  An array to check.   ", "Misc", "    Written by:   Jeremy Bailin     20 May 2011   Initial writing      IDL> print, is_sorted([0,10,15,25])        1     IDL> print, is_sorted([0,15,10,25])        0 ");
  
  

libdata[libdataItem++] = new Array("astro/jb_rgbpng.html", "jb_rgbpng.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "jb_rgbpng.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/jb_rgbpng.html#jb_rgbpng", "jb_rgbpng", "routine in <a href="astro/jb_rgbpng.html">jb_rgbpng.pro</a>", "jb_rgbpng.pro", "", "jb_rgbpng", "    Turn individual image frames into an RGB PNG image file.   ", "scale       3-element array of relative scaling for R, G, and B images respectively.  nonlinearityfilename    Name of output .PNG file.   rimage      2D image array to put in red channel. Assumed to be already scaled from 0-255.   gimage      2D image array to put in green channel. Assumed to be already scaled from 0-255.   bimage      2D image array to put in blue channel. Assumed to be already scaled from 0-255.   ", "Astro", "    A .PNG file will be written with the colour image.   ");
  
  

libdata[libdataItem++] = new Array("math/jbbilateralfilter.html", "jbbilateralfilter.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "jbbilateralfilter.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/jbbilateralfilter.html#jbbilateralfilter", "jbbilateralfilter", "routine in <a href="math/jbbilateralfilter.html">jbbilateralfilter.pro</a>", "jbbilateralfilter.pro", "", "jbbilateralfilter", "    Implements the bilateral filter on an image.      Uses the Paris & Durand (2006) algorithm. Note that there is heavy    memory optimization because the application it was written for runs    it on extremely large images.   ", "image       2D array to be filtered.   sigma_space Gaussian width in the spatial dimensions.   sigma_range Gaussian width in the intensity dimension.   ", "Math", "   Original release by Jeremy Bailin, 3 Dec 2012    Bug fixes (floating point locations for      trilinear interpolation, /edge_zero      instead of /edge_truncate) and improved documentation 4 Dec 2012    Added lots of TEMPORARY and SHRINKINTTYPE calls to improve memory usage   6 Dec 2012   ");
  
  

libdata[libdataItem++] = new Array("math/jbcrossp.html", "jbcrossp.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "jbcrossp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/jbcrossp.html#jbcrossp", "jbcrossp", "routine in <a href="math/jbcrossp.html">jbcrossp.pro</a>", "jbcrossp.pro", "", "jbcrossp", "    Calculate the cross products between two arrays of 3-vectors.   ", "v1  First 3xN array.   v2  Second 3xN array.   ", "Math", "     Written by:    Jeremy Bailin      12 June 2008   Public release in JBIU      IDL> a = [ [0.1, -1.0, 3.5], [-1.0, -1.0, 4.0] ]     IDL> b = [ [0.2, -2.0, 7.0], [2.5, -2.5, 1.0] ]     IDL> PRINT, JBCROSSP(a,b)           0.00000      0.00000      0.00000           9.00000      11.0000      5.00000     A 3xN array, where each Result[*,i] 3-vector is equal to     CROSSP(V1[*,i], V2[*,i]).   ");
  
  

libdata[libdataItem++] = new Array("astro/jbimatch.html", "jbimatch.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "jbimatch.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/jbimatch.html#jbimatch", "jbimatch", "routine in <a href="astro/jbimatch.html">jbimatch.pro</a>", "jbimatch.pro", "    Jeremy Bailin   ", "jbimatch", "  Determines the relative scaling of different images based on the measured  output of the IRAF task MSCIMATCH.   All scalings (and optionally zero points, if /ZERO is set) will be printed to  the screen. If the user requests it via the dialog, the MSCSCALE and MSCZERO  keywords of the FITS files will also be modified  ", "zero      Fit zero points if /ZERO is set. Otherwise, just fit slopes.   datfile      Name of the datfile generated using MSCIMATCH with the  measured  keyword.   ", "Astro", "    14 Oct 2011   First release     18 Oct 2011   Turned into widget program     20 Oct 2011   Comments re-written, put into JBIU   ");
  
  

libdata[libdataItem++] = new Array("math/jblinfit.html", "jblinfit.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "jblinfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/jblinfit.html#jblinfit", "jblinfit", "routine in <a href="math/jblinfit.html">jblinfit.pro</a>", "jblinfit.pro", "", "jblinfit", "    Performs least squares fitting to a straight line, but can perform it over     one particular dimension for a multi-dimensional data set. Acts like the     built-in function LINFIT if DIMENSION is not set.   ", "dimensionIf X and Y are multi-dimensional arrays, perform the fitting                accross this dimension.   chisqr   Output variable containing the chi squared values.   covar    Output variable containing the covariance matrix.   measure_errors Array containing the measurement errors in Y.   prob     Output variable containing the probability of obtaining a fit                with at least this chi squared value.   sigma    Output variable containing uncertainties in fit parameters.   yfit     Output variable containing the values of the dependent variable at                the X locations, according to the fit.   x        Array containing the independent variable values.   y        Array containing the dependent variable values.   ", "Math", "    Written by:   Jeremy Bailin     28 March 2011   Initial writing.       seed = 43l     n = 10000L     x = 1e-3 * findgen(n)     y1 = x + randomn(seed, n)     y2 = 10. - 2 * x + 0.5 * randomn(seed, n)     x = [[x],[x]]     y = [[y1],[y2]]      result = jblinfit(x, y, sigma=sigma, yfit=yfit, dimension=1)      xax = [0,10]     cgplot, psym=3, x, y1, yrange=minmax(y), color='red'     cgplot, /overplot, psym=3, x, y2, color='blue'     cgplot, /overplot, xax, result[0,0] + result[1,0]*xax, color='red'     cgplot, /overplot, xax, result[0,1] + result[1,1]*xax, color='blue'      cgtext, x[9000], yfit[9000,0] + 2, color='red', align=1, $       string(result[0,0], sigma[0,0], result[1,0], sigma[1,0], $       format='(% y = (%0.2f +/- %0.2f) + (%0.3f +/- %0.3f) x )'), $       charsize=1.5     cgtext, x[9000], yfit[9000,1] - 3, color='blue', align=1, $       string(result[0,1], sigma[0,1], result[1,1], sigma[1,1], $       format='(% y = (%0.2f +/- %0.2f) + (%0.3f +/- %0.3f) x )'), $       charsize=1.5     Returns the parameters of the linear fit. If X has dimensions [D1, D2, D3... DM],     and DIMENSION=N, then Result has dimensions [2, D1...DN-1, DN+1...DM].     Result[0,....] contains the constant term and Result[1,...] contains the slope.   ");
  
  

libdata[libdataItem++] = new Array("math/jbmajorityfilter.html", "jbmajorityfilter.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "jbmajorityfilter.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/jbmajorityfilter.html#jbmajorityfilter", "jbmajorityfilter", "routine in <a href="math/jbmajorityfilter.html">jbmajorityfilter.pro</a>", "jbmajorityfilter.pro", "", "jbmajorityfilter", "", "data  2D array to be filtered   ", "          -1", "   Written by: Jeremy Bailin    7 March 2013       Result will be the input Data with values replaced if at least half of the     surrounding 8 pixels (fewer for edges and corners) have a common value.     If the neighbours are exactly split between 4-and-4, then the choice of     which to use is arbitrary.   ");
  
  

libdata[libdataItem++] = new Array("plot/jbsymbol.html", "jbsymbol.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "jbsymbol.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/jbsymbol.html#jbsymbol", "jbsymbol", "routine in <a href="plot/jbsymbol.html">jbsymbol.pro</a>", "jbsymbol.pro", "", "jbsymbol", "    Loads one of a series of useful user-defined symbols.       Uses VSYM for symbols 5, 7 and 8, and USERSYM for the others.   ", "_extra All extra keywords (such as /FILL or THICK) are passed to              VSYM or USERSYM as appropriate.   sym    Symbol number, chosen from: :         0   Square         1   Triangle         2   Diamond         3   Half circle (left)         4   Upside-down triangle         5   5-pointed star         6   Circle         7   6-pointed star         8   Pentagon         9   Half circle (right)         10  Sun symbol  ", "Plot", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU      JBSYMBOL, 7     PLOT, [0.5], [0.5], PSYM=8, XRANGE=[0,1], YRANGE=[0,1] ");
  
  

libdata[libdataItem++] = new Array("astro/match_nd.html", "match_nd.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "match_nd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/match_nd.html#match_nd", "match_nd", "routine in <a href="astro/match_nd.html">match_nd.pro</a>", "match_nd.pro", "", "match_nd", "    For each arbitrarily-dimensioned point in one vector, determines the closest     point in a second vector. Method is to take the list returned by MATCHALL_ND     and narrow it down to the closest match.   ", "mindist Optional output containing an array of the actual distance               to the closest match for each element of P1.   one_to_one Enforces one-to-one matching. By default, matching can                  be many-to-one, i.e. one entry in P2 can be the                  closest match to several entries in P1. If                  /ONE_TO_ONE is given, then each multiple entry in P2                  is first assigned to its closest point in P1. Then any                  entries in P1 that have lost their match are assigned                  the next closest point within MaxDistance. This process is                  iterated until all points in P1 are matched to a                  unique point in P2 or there are no more points                  within MaxDistance.   p1     N1 x D array of D-dimensional coordinates.   p2     N2 x D array of D-dimensional coordinates.   maxdistance Maximum D-dimensional distance.   ", "Astro", "    Written by:    Jeremy Bailin     10 June 2008   Public release in JBIU as WITHINSPHRAD     24 April 2009  Vectorized as WITHINSPHRAD_VEC     25 April 2009  Polished to improve memory use     9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing                    heavily from JD Smith's MATCH_2D     13 May 2009    Removed * from LHS index in final remapping for speed     23 August 2010 Modified to only return closest match as WITHINSPHRAD_CLOSEST                    (importing some stuff back from MATCH_2D)     8 Sept 2010    Renamed MATCH_SPH. Added /ONE_TO_ONE option, and modified                    to explicitly call MATCHALL_SPH and then cull.     9 Feb 2011     Forked as MATCH_ND to handle Euclidean case of arbitrary dimension.     13 April 2011  Fixed to work around cumulative total 1-element array bug.      na = 10     nb = 1000     a = randomn(seed, na, 3)     b = 2. * randomu(seed, nb, 3) - 1     matches = match_nd(a, b, 0.3)     iplot, /scatter, /iso, b[*,0], b[*,1], b[*,2]     iplot, /overplot, /scatter, a[*,0], a[*,1], a[*,2], sym_index=6, $       sym_color=[255,0,0]     for i=0L, na-1 do if matches[i] ne -1 then $       iplot, /overplot, [a[i,0], b[matches[i],0]], [a[i,1], b[matches[i],1]], $         [a[i,2], b[matches[i],2]], sym_index=0, color=[255,0,0]     The function returns an array with one entry for each P1     element containing the index in P2 that is closest, or -1 if     there are none within MaxDistance.   ");
  
  

libdata[libdataItem++] = new Array("astro/match_sph.html", "match_sph.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "match_sph.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/match_sph.html#match_sph", "match_sph", "routine in <a href="astro/match_sph.html">match_sph.pro</a>", "match_sph.pro", "", "match_sph", "    For each angular point in one vector, determines the closest angular match     from another vector. Method is to take the list returned by     MATCHALL_SPH and narrow it down to the closest match.   ", "mindist Optional output containing an array of the actual distance                to the closest match for each element of Ra1, Dec1.   one_to_one Enforces one-to-one matching. By default, matching can                  be many-to-one, i.e. one entry in Ra2,Dec2 can be the                  closest match to several entries in Ra1,Dec1. If                  /ONE_TO_ONE is given, then each multiple entry in Ra2,Dec2                  is first assigned to its closest point in Ra1,Dec1. Then any                  entries in Ra1,Dec1 that have lost their match are assigned                  the next closest point within Sphrad. This process is                  iterated until all points in Ra1,Dec1 are matched to a                  unique point in Ra2,Dec2 or there are no more points                  within Sphrad   ra1    Vector of longitude coordinates, in degrees.   dec1   Vector of latitude coordinates, in degrees.   ra2    Vector of longitude coordinates, in degrees.   dec2   Vector of latitude coordinates, in degrees.   sphrad Maximum angular distance, in degrees. Matches outside              of this radius are ignored.   ", "Astro", "    Written by:    Jeremy Bailin     10 June 2008   Public release in JBIU as WITHINSPHRAD     24 April 2009  Vectorized as WITHINSPHRAD_VEC     25 April 2009  Polished to improve memory use     9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing                    heavily from JD Smith's MATCH_2D     13 May 2009    Removed * from LHS index in final remapping for speed     23 August 2010 Modified to only return closest match as WITHINSPHRAD_CLOSEST                    (importing some stuff back from MATCH_2D)     8 Sept 2010    Renamed MATCH_SPH. Added /ONE_TO_ONE option, and modified                    to explicitly call MATCHALL_SPH and then cull.     13 April 2011  Fixed to work around cumulative total 1-element array bug.       n1 = 25     n2 = 10     seed = 43L     ra1 = randomn(seed, n1)     dec1 = randomn(seed, n1)     ra2 = randomn(seed, n2)     dec2 = randomn(seed, n2)     result1 = match_sph(ra1, dec1, ra2, dec2, 1.)     result2 = match_sph(ra1, dec1, ra2, dec2, 1., /one_to_one)     !p.multi=[0,2,1]     plot, psym=1, ra1, dec1, xrange=[-3,3], yrange=[-3,3], title='Default'     oplot, psym=4, ra2, dec2     for i=0l,n1-1 do if result1[i] ne -1 then oplot, [ra1[i],ra2[result1[i]]], $       [dec1[i],dec2[result1[i]]]     plot, psym=1, ra1, dec1, xrange=[-3,3], yrange=[-3,3], title='/ONE_TO_ONE'     oplot, psym=4, ra2, dec2     for i=0l,n1-1 do if result2[i] ne -1 then oplot, [ra1[i],ra2[result2[i]]], $       [dec1[i],dec2[result2[i]]]     The function returns an array with one entry for each Ra1, Dec1     element containing the index in Ra2, Dec2 that is closest, or -1 if     there are none within Sphrad.   ");
  
  

libdata[libdataItem++] = new Array("astro/matchall_2d.html", "matchall_2d.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "matchall_2d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/matchall_2d.html#matchall_2d", "matchall_2d", "routine in <a href="astro/matchall_2d.html">matchall_2d.pro</a>", "matchall_2d.pro", "", "matchall_2d", "    Determines which of a set of 2D coordinates are within a given distance from     each of a vector of points. Based on JD's MATCH_2D and my MATCHALL_SPH.   ", "distance Optional output containing the distances between each pair.                The distances are stored in the same order as the Result                array but starting at 0, i.e. if j is match number k to                element i then                    j = Result[Result[i]+k]                and the distance between points i and j is                    DISTANCE[Result[i]+k-Result[0]]   x1    Vector of X coordinates.   y1    Vector of Y coordinates.   x2    Vector of X coordinates.   y2    Vector of Y coordinates.   maxdistance Maximum distance.   nwithinA vector containing the number of matches for each of X1,Y1.   ", "Astro", "    Written by:    Jeremy Bailin     10 June 2008   Public release in JBIU as WITHINSPHRAD     24 April 2009  Vectorized as WITHINSPHRAD_VEC     25 April 2009  Polished to improve memory use     9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing                    heavily from JD Smith's MATCH_2D     13 May 2009    Removed * from LHS index in final remapping for speed     6 May 2010     Changed to MATCHALL_2D and just using Euclidean 2D coordinates                     (add a bunch of stuff back in from MATCH_2D and take out a bunch                     of angle stuff)     25 May 2010    Bug fix to allow X2 and Y2 to have any dimension.     9 Feb 2011     Added DISTANCE output keyword.      Note that the routine is similar to finding       WHERE( (X2-X1[i])^2 + (Y2-Y1[i])^2 LE Distance^2, Nwithin)     for each element of X1 and Y1, but is much more efficient.      Shows which random points are within 0.1 of various coordinates:      seed=43     nrandcoords = 5000l     xrand = 2. * RANDOMU(seed, nrandcoords) - 1.     yrand = 2. * RANDOMU(seed, nrandcoords) - 1.     xcoords = [0.25, 0.5, 0.75]     ycoords = [0.75, 0.5, 0.25]     ncoords = N_ELEMENTS(xcoords)     matches = MATCHALL_2D(xcoords, ycoords, xrand, yrand, 0.1, nmatches)     PLOT, /ISO, PSYM=3, xrand, yrand     OPLOT, PSYM=1, COLOR=FSC_COLOR('blue'), xcoords, ycoords     OPLOT, PSYM=3, COLOR=FSC_COLOR('red'), xrand[matches[ncoords+1:*]], $       yrand[matches[ncoords+1:*]]     The function returns the list of indices of X2, Y2 that lie within     Sphrad of each point X1,Y1. The format of the returned array is     similar to the REVERSE_INDICES array from HISTOGRAM: the indices     into X2,Y2 that are close enough to element i of X1,Y1 are     contained in Result[Result[i]:Result[i+1]-1] (note, however, that     these indices are not guaranteed to be sorted). If there are no matches,     then Result[i] eq Result[i+1].   ");
  
  

libdata[libdataItem++] = new Array("astro/matchall_nd.html", "matchall_nd.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "matchall_nd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/matchall_nd.html#matchallmap", "matchallmap", "routine in <a href="astro/matchall_nd.html">matchall_nd.pro</a>", "matchall_nd.pro", "", "matchallmap", "", "usemapngridaind", "          -1", "");
  
  libdata[libdataItem++] = new Array("astro/matchall_nd.html#matchall_nd", "matchall_nd", "routine in <a href="astro/matchall_nd.html">matchall_nd.pro</a>", "matchall_nd.pro", "", "matchall_nd", "    Determines which of a set of coordinates of arbitratry dimension are a     given distance from each of a vector of points. Based on JD's MATCH_2D     and my MATCHALL_SPH.   ", "distance Optional output containing the distances between each pair.                The distances are stored in the same order as the Result                array but starting at 0, i.e. if j is match number k to                element i then                    j = Result[Result[i]+k]                and the distance between points i and j is                    DISTANCE[Result[i]+k-Result[0]]   p1    N1xD array of D-dimensional coordinates.   p2    N2xD array of D-dimensional coordinates.   maxdistance Maximum D-dimensional distance.   nwithinA vector containing the number of matches for each entry in P1.   ", "Astro", "    Written by:    Jeremy Bailin     10 June 2008   Public release in JBIU as WITHINSPHRAD     24 April 2009  Vectorized as WITHINSPHRAD_VEC     25 April 2009  Polished to improve memory use     9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing                    heavily from JD Smith's MATCH_2D     13 May 2009    Removed * from LHS index in final remapping for speed     6 May 2010     Changed to MATCHALL_2D and just using Euclidean 2D                    coordinates (add a bunch of stuff back in from MATCH_2D and                    take out a bunch of angle stuff)     25 May 2010    Bug fix to allow X2 and Y2 to have any dimension.     23 August 2010 Generalized to an arbitrary number of dimensions and                    to use the manifold-mapping technique from WITHINSPHRAD_VEC3D                    if the space is sparse enough as MATCHALL_ND.     9 Feb 2010     Added DISTANCE output keyword.      Generates Gaussian 3D clouds around each of several locations and colours     the points in the cloud that lie within the Gaussian dispersion of any     location.      na = 10     nbpera = 1000     a = randomn(seed, na, 3)     b = 0.1*randomn(seed, na*nbpera, 3)     b += rebin(a, na*nbpera, 3, /sample)     result = matchall_nd(a, b, 0.1)     matches = result[na+1:*]     iplot, /scatter, /iso, b[*,0], b[*,1], b[*,2]     iplot, /overplot, /scatter, sym_color=[255,0,0], b[matches,0], $       b[matches,1], b[matches,2]     iplot, /overplot, sym_index=1, sym_color=[0,0,255], linestyle=6, a[*,0], $       a[*,1], a[*,2]     The function returns the list of indices of P2 that lie within     Distance of each point in P1. The format of the returned array is     similar to the REVERSE_INDICES array from HISTOGRAM: the indices     into P2 that are close enough to element i of P1 are     contained in Result[Result[i]:Result[i+1]-1] (note, however, that     these indices are not guaranteed to be sorted). If there are no matches,     then Result[i] eq Result[i+1].   ");
  
  

libdata[libdataItem++] = new Array("astro/matchall_sph.html", "matchall_sph.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "matchall_sph.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/matchall_sph.html#wsrad_map", "wsrad_map", "routine in <a href="astro/matchall_sph.html">matchall_sph.pro</a>", "matchall_sph.pro", "", "wsrad_map", "", "ngrida0a1a2mapusemap", "          -1", "");
  
  libdata[libdataItem++] = new Array("astro/matchall_sph.html#matchall_sph", "matchall_sph", "routine in <a href="astro/matchall_sph.html">matchall_sph.pro</a>", "matchall_sph.pro", "", "matchall_sph", "    Determines which of a set of angular coordinates on the sky (or on a     sphere) are within a given angular distance from each of a vector of     points. New optimized version that uses histograms based on 3D     locations on the unit sphere and borrows heavily from JD's MATCH_2D.   ", "distance Optional output containing the distances between each pair.                The distances are stored in the same order as the Result                array but starting at 0, i.e. if j is match number k to                element i then                    j = Result[Result[i]+k]                and the distance between points i and j is                    DISTANCE[Result[i]+k-Result[0]]   ra1    Vector of longitude coordinates, in degrees.   dec1   Vector of latitude coordinates, in degrees.   ra2    Vector of longitude coordinates, in degrees.   dec2   Vector of latitude coordinates, in degrees.   sphrad Maximum angular distance, in degrees.   nwithinA vector containing the number of matches for each of Ra1,Dec1.   ", "Astro", "    Written by:    Jeremy Bailin     10 June 2008   Public release in JBIU as WITHINSPHRAD     24 April 2009  Vectorized as WITHINSPHRAD_VEC     25 April 2009  Polished to improve memory use     9 May 2009     Radical efficiency re-write as WITHINSPHRAD_VEC3D borrowing                    heavily from JD Smith's MATCH_2D     13 May 2009    Removed * from LHS index in final remapping for speed     8 Sept 2010    Renamed MATCHALL_SPH and added DISTANCE keyword     9 Aug 2011     Bug fix: incorrect bin size caused occasional matches                    to be missed (thanks to J. Donley for reporting)      Note that the routine is similar to finding       WHERE(SPHDIST(Ra1,Dec1,Ra2,Dec2,/DEGREE) LE Sphrad, Nwithin)     for each element of Ra1 and Dec1, but is much more efficient.      Shows which random points are within 10 degrees of various coordinates:      seed=43     nrandcoords = 5000l     ra_randcoords = 360. * RANDOMU(seed, nrandcoords)     dec_randcoords = ASIN( 2*RANDOMU(seed, nrandcoords)-1 ) * !RADEG     ra_centers = 60. * FINDGEN(5)     dec_centers = [0., 45., 0., -45., 90.]     matches = MATCHALL_SPH(ra_centers, dec_centers, ra_randcoords, $       dec_randcoords, 10., nmatches)     plot, /iso, psym=3, ra_randcoords, dec_randcoords     oplot, psym=1, color=fsc_color('blue'), ra_centers, dec_centers     oplot, psym=3, color=fsc_color('red'), ra_randcoords[matches[6:*]], $       dec_randcoords[matches[6:*]]     The function returns the list of indices of Ra2, Dec2 that lie within     Sphrad of each point Ra1,Dec1. The format of the returned array is     similar to the REVERSE_INDICES array from HISTOGRAM: the indices     into Ra2,Dec2 that are close enough to element i of Ra1,Dec1 are     contained in Result[Result[i]:Result[i+1]-1] (note, however, that     these indices are not guaranteed to be sorted). If there are no matches,     then Result[i] eq Result[i+1].   ");
  
  

libdata[libdataItem++] = new Array("math/matrix2quaternion.html", "matrix2quaternion.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "matrix2quaternion.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/matrix2quaternion.html#matrix2quaternion", "matrix2quaternion", "routine in <a href="math/matrix2quaternion.html">matrix2quaternion.pro</a>", "matrix2quaternion.pro", "", "matrix2quaternion", "    Transforms a rotation matrix into a quaternion.   ", "rotmatrix  A 3x3 rotation matrix.   ", "Math", "    Written by:   Jeremy Bailin     27 Nov 2008   Released in JBIU       IDL> theta=!PI/3.     IDL> rm = [[COS(theta),0,-SIN(theta)],[0,1,0],[SIN(theta),0,COS(theta)]]     IDL> quat = MATRIX2QUATERNION(rm)     IDL> PRINT, quat           0.00000    -0.50000      0.00000     0.866025     The function returns the quaternion corresponding to the rotation     specified by the rotation matrix.   ");
  
  

libdata[libdataItem++] = new Array("astro/mean_by_radaz.html", "mean_by_radaz.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "mean_by_radaz.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/mean_by_radaz.html#mean_by_radaz", "mean_by_radaz", "routine in <a href="astro/mean_by_radaz.html">mean_by_radaz.pro</a>", "mean_by_radaz.pro", "", "mean_by_radaz", "    Calculates the mean value of an image in bins of both radius and     pie slices of azimuthal angle.   ", "rbin       Size of radial bins (in pixels). Default: 1.  ntheta     Number of azimuthal bins. Default: 8.  center     Pixel co-ordinate to consider the center. May be                  non-integer, or even off the image (as long as                  /CROPCIRCLE is not set). Default: Image center.  cropcircle Set this keyword to crop out the corners of                  the image, i.e. use only those pixels within the largest                  circle that is fully enclosed in the image.  rotation   Start the first azimuthal bin at an angle ROTATION                  (in radians) from the x-axis. Default: 0.  nan        Set this keyword to check for NaN or Infinity when                  calculating the means. Any such elements are treated                  as missing data.   image 2D image array.   ", "Astro", "    Written by:    Jeremy Bailin, in response to a question by Andy Bohn.     17 June 2008   Public release in JBIU     18 June 2008   Fixed typo in documentation       Calculate the radial and azimuthal means of some image data, cutting     out the  corners  that aren't fully sampled to the same radii. Use     radial bins 2 pixels wide and azimuthal bins 30 degrees wide.      imagedata = dist(25,25)     imagemeans = MEAN_BY_RADAZ(imagedata, RBIN=2, NTHETA=12, /CROPCIRCLE)     This function returns a structure containing the inner radii of each     radial bin (tagged 'RADIAL_AXIS'), the image mean within each radial     bin (tagged 'RADIAL_MEAN'), the starting azimuth of each azimuthal     bin (tagged 'AZIMUTHAL_AXIS'), and the image mean within each azimuthal     pie slice (tagged 'AZIMUTHAL_MEAN'). Note that azimuthal angle is     calculated counterclockwise starting at the x-axis (unless ROTATION     is specified).   ");
  
  

libdata[libdataItem++] = new Array("math/minfinite.html", "minfinite.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "minfinite.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/minfinite.html#minfinite", "minfinite", "routine in <a href="math/minfinite.html">minfinite.pro</a>", "minfinite.pro", "", "minfinite", "    Calculate the minimum non-zero value of an array.   ", "x   Array   index The index of the minimum value.   ", "Math", "     Written by:    Jeremy Bailin      17 May 2011    Initial writing      IDL> a = [1, 0, 2]     IDL> print, MINFINITE(a, i)            1     IDL> print, i                0     A scalar containing the minimum non-zero value of X. If there     are none, returns 0.   ");
  
  

libdata[libdataItem++] = new Array("math/ml_distfit.html", "ml_distfit.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "ml_distfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/ml_distfit.html#ML_NNL", "ML_NNL", "routine in <a href="math/ml_distfit.html">ml_distfit.pro</a>", "ml_distfit.pro", "", "ML_NNL", "", "P", "          -1", "");
  
  libdata[libdataItem++] = new Array("math/ml_distfit.html#hessian", "hessian", "routine in <a href="math/ml_distfit.html">ml_distfit.pro</a>", "ml_distfit.pro", "", "hessian", "", "nameparamcorrel", "          -1", "");
  
  libdata[libdataItem++] = new Array("math/ml_distfit.html#derivee2xy", "derivee2xy", "routine in <a href="math/ml_distfit.html">ml_distfit.pro</a>", "ml_distfit.pro", "", "derivee2xy", "", "namexparamnxny", "          -1", "");
  
  libdata[libdataItem++] = new Array("math/ml_distfit.html#ML_DISTFIT", "ML_DISTFIT", "routine in <a href="math/ml_distfit.html">ml_distfit.pro</a>", "ml_distfit.pro", "", "ML_DISTFIT", "    Performs maximum likelihood fitting of a distribution.   ", "FITA          Vector of which parameters should be fit (1 for each                     parameter to be fit, 0 for each parameter to be held                     constant).                     THERE IS A BUG IN THE IMPLEMENTATION. DO NOT USE.   LIKELIHOOD    Outputs an M-dimensional array with the likelihood                     values over the range of parameter space probed. M is                     the number of parameters that are fitted, which can be                     less than the length of Parm if FITA is used.   LIKERANGE     2xM dimensional array containing the bounds of the                     LIKELIHOOD array.   CONSTRAINT    Name of a user-supplied function that takes a parameter                     vector as input and returns 1 if the point in parameter                     space is permitted and 0 if it is not permitted.   X             Array of input data values. This is passed straight to the                     user-supplied function, so complicated data structures that                     encompass multi-dimensional information for each data                     point can be used.   Parm          Variable containing initial guesses for parameters on input                     and best fit values on output.   Function_Name Name of user-supplied function defining the distribution.                     The function must accept 2 arguments, X and Parm, and                     return a vector containing the likelihood values for                     each data point in X for the point in parameter space                     given by Parm. The likelihood must be normalized so                     that its total integral over all possible values of X                     is a constant, regardless of Parm (it makes the most                     sense to normalize this integral to unity, but that                     is not strictly required).   ConfRegion    Lower and upper error estimates of each parameter,                     marginalized over the other parameters.                     I.e. ConfRegion[*,0] returns [low0,high0]                     where low0 <= parm[0] <= high0   ", "Math", "     Written by: Jeremy Bailin. Thanks to the writers of MLEfit.pro, which                  furnished the Hessian routines, Peder Norberg for useful                  discussions, and Nicolas Petitclerc for additional testing.      27 Nov 2008 Release in JBIU.       Fit the width and offset of a zero-centered Gaussian plus constant     distribution.      First, define the distribution function:     FUNCTION gauss_plus_const, X, Parm       ; Parm[0]=constant offset, Parm[1]=width sigma       vmax = 2000.       normalization = Parm[1]*SQRT(!pi/2.)*ERF(vmax/(SQRT(2.)*Parm[1])) $         + vmax*Parm[0]       distribution = EXP(-X^2/(2.*Parm[1]^2)) + Parm[0]       RETURN, distribution/normalization     END      Then generate some data that should adhere to this distribution,     with a width of 250 and a constant term containing 10% of the points.     IDL> data = [250*RANDOMN(seed, 900), 4000*(RANDOMU(seed, 100) - 0.5)]      And finally fit the distribution:     IDL> parm = [0., 100.]     IDL> ML_DISTFIT, data, parm, 'gauss_plus_const', parmconf     IDL> PRINT, parm          0.0625345         223.94577     IDL> PRINT, parmconf         0.057511609  0.0973332           207.087      243.841 ");
  
  

libdata[libdataItem++] = new Array("astro/mm_dist.html", "mm_dist.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "mm_dist.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/mm_dist.html#mM_dist", "mM_dist", "routine in <a href="astro/mm_dist.html">mm_dist.pro</a>", "mm_dist.pro", "", "mM_dist", "    Converts between distance modulus m-M and distance in parsecs.   ", "mM  Input distance modulus m-M.   distInput distance in parsecs.   ", "Astro", "    Written by:   Jeremy Bailin     10 June 2008  Public release in JBIU      Calculate distance of an object with distance modulus m-M=16.8:      distance = mM_DIST(mM=16.8)      Calculate the distance modulus of an object at 350pc:      distmod = mM_DIST(DIST=350.)     If mM is specified, then Result is the distance in parsecs. If DIST     is specified, then Result is the distance modulus m-M.   ");
  
  

libdata[libdataItem++] = new Array("misc/multi2index.html", "multi2index.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "multi2index.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/multi2index.html#multi2index", "multi2index", "routine in <a href="misc/multi2index.html">multi2index.pro</a>", "multi2index.pro", "", "multi2index", "    Translates multidimensional indices into flat indices (the inverse     of ARRAY_INDICES).   ", "subscripts  Multidimensional indices. If Dimensions has D                   elements, then Subscripts is a DxQ dimensional                   array to translate Q sets of indices. Q may be                   1 (or, equivalently, missing).   dimensions  An array containing the length of each dimension in                   the multidimensional array.   ", "Misc", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU     26 May  2010   Added /INTEGER keyword to PRODUCT and TOTAL calls.      If a is an LxMxN array, the following expressions are equivalent:      a[sub1, sub2, sub3]     a[ multi2index([sub1, sub2, sub3], [L, M, N]) ]     Flat indices into an array with the given dimensions.   ");
  
  

libdata[libdataItem++] = new Array("math/ord.html", "ord.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "ord.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/ord.html#ord", "ord", "routine in <a href="math/ord.html">ord.pro</a>", "ord.pro", "", "ord", "    Calculates the ordinal of each value of an array in terms of the     sorted values. This can be very useful for shrinking sparse     arrays before using histogram.   ", "values A vector of values.   ", "Math", "    Written by:      Jeremy Bailin     28 March 2009    Public release in JBIU     17 June 2011     Output same dimensional array as input, rather than flat.      7 March 2013    Bugfix when there is only one unique value - Mats Loefdahl     27 May 2015      Switched to use value_locate.      Calculate the ordinals of values in an array.      IDL> array = [5,6,7,4,5,6,-2]     IDL> print, ord(array)                2           3           4           1           2           3                0     Returns a long array with the same number of elements as Values,     where each value is replaced by its ordinal (starting at 0).     Identical values are given the same ordinal.   ");
  
  

libdata[libdataItem++] = new Array("math/percentiles.html", "percentiles.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "percentiles.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/percentiles.html#percentiles", "percentiles", "routine in <a href="math/percentiles.html">percentiles.pro</a>", "percentiles.pro", "", "percentiles", "    Determines what range of a distribution lies within a percentile range.   ", "conflimit The fraction of the distribution encompassed. Default: 0.68   values Array containing the distribution.   ", "Math", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU      IDL> a = 0.01*FINDGEN(101)     IDL> PRINT, PERCENTILES(a, CONFLIMIT=0.8)         0.1000000     0.900000    A 2-element vector of values that encompass a fraction CONFLIMIT    of the distribution. For example, if CONFLIMIT=0.68 then Result gives    the 16th and 85th percentiles.   ");
  
  

libdata[libdataItem++] = new Array("plot/plot_binneddata.html", "plot_binneddata.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "plot_binneddata.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/plot_binneddata.html#plot_binneddata", "plot_binneddata", "routine in <a href="plot/plot_binneddata.html">plot_binneddata.pro</a>", "plot_binneddata.pro", "", "plot_binneddata", "    Takes a set of X,Y data and plots the mean y value for points     binned by their x coordinate.   ", "MIN      Minimum value for bins. Default: minimum value of X.   MAX      Maximum value for bins. Default: maximum value of X.   ERRORBAR If /ERRORBAR is set, then error bars are plotted in the y                direction. The size of the error bar is the statistical                error in the mean (or, if /MEDIAN is set, the range                containing the fraction CONFLIMIT of the data).   OVERPLOT If /OVERPLOT is set then overplot binned data points on                an existing plot.   NOPLOT   If /NOPLOT is set then do not create a plot. Useful if                you just want to extract the values using the O...                keywords.   OX       Optional output of x coordinates of bins.   ODATA    Optional output of plotted y values.   OERR     Optional output 2xNbin array containg the ends of the                error bars.   COLOR     Color of plotted points and error bars.   DX       Shifts the x coordinates of the plot locations (only on                the plot, not in OX).   MEDIAN   If /MEDIAN is set then plot the median Y value instead                of the mean.   HORIZONTALBAR  If /HORIZONTALBAR is set then the routine plots a                      horizontal line that spans each bin.   CONFLIMITFraction of the data to enclose in the error bar if                /MEDIAN is set. For example, use CONFLIMIT=0.9 to                plot the 5th to 95th percentile range.   ROBUST   If /ROBUST is set then use ROBUST_MEAN to calculate the                mean Y value. Not compatible with /MEDIAN.   HISTOGRAM Outputs the histogram of number of Data values that                contributed to each bin. Not compatible with negative                values for Bin.   REVERSE_INDICES Outputs the reverse indices of the histogram.                      Not compatible with negative values for Bin.   _EXTRAExtra keywords are passed through to CGPLOT.   WINDOW    Sets the /WINDOW keyword in Coyote Graphics.   ADDCMD    Sets the /ADDCMD keyword in Coyote Graphics.   X    Array containing x coordinates of data points.   DATA Array containing y coordinates of data points.   BIN  Bin width, in x coordinates (if positive) or in            data points per bin (if negative).   ", "Plot", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU     3 May 2009     When BIN<0, make all bins have approximately the                    same number of elements instead of sticking any                    excess elements in the final bin.     12 July 2010   Added /ROBUST keyword.     31 July 2010   Added HISTOGRAM and REVERSE_INDICES keywords.     11 March 2011  Switched to Coyote Graphics.      x = 0.1*FINDGEN(20)     y = 10. * x^2 + RANDOMN(seed, 20)     PLOT, PSYM=3, x, y     PLOT_BINNEDDATA, x, y, -4, /OVERPLOT, /ERRORBAR ");
  
  

libdata[libdataItem++] = new Array("plot/plotcumul.html", "plotcumul.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "plotcumul.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/plotcumul.html#plotcumul", "plotcumul", "routine in <a href="plot/plotcumul.html">plotcumul.pro</a>", "plotcumul.pro", "", "plotcumul", "    Plots the cumulative distribution of a set of data.   ", "overplot   If /OVERPLOT is set then overplot the cumulative                  distribution over top of the existing plot coordinates.   absolute   If /ABSOLUTE is set then plot the true cumulative number                  distribution instead of the fractional cumulative                  distribution.   window     Sets the /WINDOW keyword in Coyote Graphics.   addcmd     Sets the /ADDCMD keyword in Coyote Graphics.   _extraAll extra keywords are passed through to CGPLOT.   data  Data values.   ", "Plot", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU     11 March 2011  Switched to Coyote Graphics.      x = findgen(20)^2     PLOTCUMUL, x, YRANGE='Cumulative Fraction'     Plots or overplots the cumulative distribution of Data.   ");
  
  

libdata[libdataItem++] = new Array("misc/pnginterp.html", "pnginterp.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "pnginterp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/pnginterp.html#pnginterp", "pnginterp", "routine in <a href="misc/pnginterp.html">pnginterp.pro</a>", "pnginterp.pro", "", "pnginterp", "    Interpolates between two grayscale .PNG images.   ", "png1    String containing the name of the first (t=0) image.   png2    String containing the name of the second (t=1) image.   times   One or more times at which to write interpolated images.               These may outside the range 0 to 1 as long as this does               not cause a byte overflow.   outnamesAn array of file names to write the output images to.               Must be the same length as Times.   ", "Misc", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU      PNGINTERP, 'file0.png', 'file1.png', [0.25,0.5,0.75],       ['file025.png', 'file05.png', 'file075.png'] ");
  
  

libdata[libdataItem++] = new Array("math/point_convolve.html", "point_convolve.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "point_convolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/point_convolve.html#point_convolve", "point_convolve", "routine in <a href="math/point_convolve.html">point_convolve.pro</a>", "point_convolve.pro", "", "point_convolve", "    Convolves a list of N-dimensional points with a Gaussian kernel.       By default, this function uses an FFT and the convolution theorem.     If /NOFFT is set, then it uses the built-in CONVOL function. If     either /NOCONVOL is set or SIGMA is an MxN array, then it uses     manual summation.   ", "points   Array of MxN points for M dimensions and N particles (required).   binsize  Bin sizes for final output grid. Either a scalar or an                array of length M. (required)   range    Array of Mx2, containing the extent of output grid                in each dimension. (required)   sigma    Width of Gaussian kernel. May either be a scalar that is                applied to all dimensions, an array of length M for                different widths in each dimension, OR an MxN array                containing a separate width for each particle and                dimension (this option uses manual summation as if                /NOCONVOL were set, and is therefore much slower).                (required)   weightAn array of length N containing the weight to assign to             each point. A weight of 1 (default) corresponds to a Gaussian             normalized such that its integral over the entire M-dimensional             space is unity.   cutoffAssume that the kernel may be safely truncated after this many             SIGMAs. Default: 8 (corresponding to a dynmical range of 7.9e13).   noconvol If /NOCONVOL is set than use manual summation rather than an FFT.   nofft    If /NOFFT is set then use the built-in CONVOL routine rather                than an FFT.   ", "Math", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU     15 Apr 2008   Fixed off-by-one bug and improved memory usage     27 March 2013 Speed improvements      xpos = 10.*RANDOMU(seed,100)     ypos = 20.*RANDOMU(seed,100)     density = POINT_CONVOLVE(POINTS=TRANSPOSE([[xpos],[ypos]]),       BINSIZE=1., RANGE=[[0.,0.], [10.,20.]], SIGMA=[2.,4.])     An grid containing the output density field. Each dimension i in the output     grid has length (RANGE[i,1]-RANGE[i,0])/BINSIZE[i]. Returns -1 on error.   ");
  
  

libdata[libdataItem++] = new Array("astro/potential_newton.html", "potential_newton.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "potential_newton.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/potential_newton.html#potential_newton", "potential_newton", "routine in <a href="astro/potential_newton.html">potential_newton.pro</a>", "potential_newton.pro", "", "potential_newton", "       Calculates the gravitational potential from a particle distribution        at a list of positions.   ", "lengthunitLength unit, in cm (or kpc if /ASTRO is set). Default: 1kpc.   massunit  Mass unit, in grams (or solar masses if /ASTRO is                    set). Default: 1 solar mass.   astro     If /ASTRO is set then LENGTHUNIT and MASSUNIT are given                    in kpc and solar masses respectively, otherwise they are                    in CGS (Lengthunit in cm, Massunit in grams).   softening Plummer softening length. Default: 0 (no softening).   lomem     If /LOMEM is set then sacrifice efficiency for                    lower memory usage   x    X coordinates at which to calculate potential.   y    Y coordinates at which to calculate potential.   z    Z coordinates at which to calculate potential.   xpartX coordinates of particle positions defining the mass               distribution.   ypartY coordinates of particle positions defining the mass               distribution.   zpartZ coordinates of particle positions defining the mass               distribution.   mass Mass of each particle.   ", "Astro", "       Written by:    Jeremy Bailin        10 June 2008   Public release in JBIU          Calculate the gravitational potential on a line along the x-axis from        6 point masses placed at the vertices of a cube:         xmasspos = [-1,-1,-1,-1,1,1,1,1]        ymasspos = [-1,-1,1,1,-1,-1,1,1]        zmasspos = [-1,1,-1,1,-1,1,-1,1]        masses = REPLICATE(1.,8)        xlinepos = 0.1*FINDGEN(20)        ylinepos = REPLICATE(0.,20)        zlinepos = REPLICATE(0.,20)        potentials = POTENTIAL_NEWTON(xlinepos, ylinepos, zlinepos, xmasspos, ymasspos,          zmasspos, masses)        This function returns the gravitational potential at each X,Y,Z position.        If there are NPOS positions, Result is a vector of length NPOS.   ");
  
  

libdata[libdataItem++] = new Array("misc/push.html", "push.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "push.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/push.html#push", "push", "routine in <a href="misc/push.html">push.pro</a>", "push.pro", "", "push", "    Adds an element to the end of a (possibly non-existent) array.   ", "array  An array to which the values are to be added. The array              is created if it doesn't already exist.   value  A value to be added to the end of Array. Must be the              same type as Array.   ", "Misc", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU      IDL> PUSH, a, 5     IDL> PRINT, a         5     IDL> PUSH, a, 8     IDL> PRINT, a         5      8 ");
  
  

libdata[libdataItem++] = new Array("math/quat2rotaxis.html", "quat2rotaxis.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "quat2rotaxis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/quat2rotaxis.html#quat2rotaxis", "quat2rotaxis", "routine in <a href="math/quat2rotaxis.html">quat2rotaxis.pro</a>", "quat2rotaxis.pro", "", "quat2rotaxis", "    Returns the net axis and angle of the rotation specified by the     input quaternion.   ", "quat   A quaternion specifying a rotation.   ", "Math", "    Written by:   Jeremy Bailin     27 Nov 2008   Released in JBIU       IDL> theta=!PI/3.     IDL> rm = [[COS(theta),0,-SIN(theta)],[0,1,0],[SIN(theta),0,COS(theta)]]     IDL> quat = MATRIX2QUATERNION(rm)     IDL> rotation = QUAT2ROTAXIS(quat)     IDL> PRINT, rotation           0.00000    -1.000000      0.00000     1.04720     The function returns a 4-element vector. The first 3 elements are     the axis of the rotation and the 4th element is the     magnitude of the rotation in radians.   ");
  
  

libdata[libdataItem++] = new Array("astro/readdolphot.html", "readdolphot.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "readdolphot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/readdolphot.html#readdolphot", "readdolphot", "routine in <a href="astro/readdolphot.html">readdolphot.pro</a>", "readdolphot.pro", "", "readdolphot", "        Read the output of the DOLPHOT photometry package into easier-to-         use data structures.   ", "nhstfilters  If this is set to a number greater than 0, the output                        is assumed to have been generated using DOLPHOT/ACS                        or DOLPHOT/WFC3, and to have NHSTFILTERS photometry                        blocks at the beginning that give the combined results                        of each filter. The output is also assumed to both                        have instrumental and transformed magnitudes.   v2           If /V2 set, then read in DOLPHOT 2 output (slightly changed                        from version 1)   filename     Name of DOLPHOT output file   nimg         Number of images   ", "Astro", "         Written by:     Jeremy Bailin          13 May 2010     Initial writing          18 June 2011    Updated to allow DOLPHOT2 output           This function outputs an array of structures, one for each star.         The structure has the following fields:            extension, chip, xpos, ypos, chi, sn, sharpness, roundness,            majoraxis, crowding, objtype, counts[N], background[N],            magnitude[N], magerr[N], imgchi[N], imgsn[N], imgsharpness[N],            imgroundness[N], imgcrowding[N], fwhm[N], ellipticity[N],            PSFa[N], PSFb[N], PSFc[N], errflag[N].          If NHSTFILTERS gt 0 then magnitude[N] is replaced by instmag[N]          and transfmag[N].          If /V2 is set, then fwhm[N], ellipticity[N], PSFa[N],          PSFb[N] and PSFc[N] are replaced with ctcorr[N] and dctcorr[N].          N is Nimg plus NHSTFILTERS. The HST filter information comes          first.   ");
  
  

libdata[libdataItem++] = new Array("astro/readfakedolphot.html", "readfakedolphot.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "readfakedolphot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/readfakedolphot.html#readfakedolphot", "readfakedolphot", "routine in <a href="astro/readfakedolphot.html">readfakedolphot.pro</a>", "readfakedolphot.pro", "", "readfakedolphot", "        Read the output of the DOLPHOT photometry package when run in         artificial star mode into easier-to-use data structures.   ", "nhstfilters  If this is set to a number greater than 0, the output                        is assumed to have been generated using DOLPHOT/ACS                        or DOLPHOT/WFC3, and to have NHSTFILTERS photometry                        blocks at the beginning that give the combined results                        of each filter (unless Nimg is 1). The output is also                        assumed to both have instrumental and transformed magnitudes.                        I don't know what DOLPHOT does with artificial stars                        when there are more than 2 filters, so I'm just going to                        assume that there are never more than 2 filters.   filename     Name of DOLPHOT output file   fakestarlist Name of file containing list of fake stars   nimg         Number of images   ", "Astro", "         Written by:     Jeremy Bailin          13 May 2010     Initial writing          13 Jan 2011     Bug fixes for NHSTFILTERS ne 0           This function outputs an array of structures, one for each star.         The structure has the following fields:            extension, chip, xpos, ypos, chi, sn, sharpness, roundness,            majoraxis, crowding, objtype, counts[N], background[N],            magnitude[N], magerr[N], imgchi[N], imgsn[N], imgsharpness[N],            imgroundness[N], imgcrowding[N], fwhm[N], ellipticity[N],            PSFa[N], PSFb[N], PSFc[N], errflag[N],            input_extension, input_chip, input_xpos, input_ypos, input_counts[N],            input_magnitude[N].          If NHSTFILTERS gt 0 then magnitude[N] is replaced by instmag[N]          and transfmag[N].          N is Nimg plus NHSTFILTERS. The HST filter information comes          first.   ");
  
  

libdata[libdataItem++] = new Array("io/readparam.html", "readparam.pro", ".pro file in <a href="io/dir-overview.html">io/ directory</a>", "readparam.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("io/readparam.html#readparam", "readparam", "routine in <a href="io/readparam.html">readparam.pro</a>", "readparam.pro", "", "readparam", "    Reads in a parameter file containing  key = value  pairs.   ", "filename   Name of parameter file.   ", "I/O", "    Written by: Jeremy Bailin     Lost in history: Was once written and then lost?!     23 May 2011   Re-written     26 May 2011   Added OBJ_DESTROY.      FIXME   REQUIRES:     Craig Markwardt's hashtable object (http://www.physics.wisc.edu/~craigm/idl/down/hashtable__define.pro).     Returns a structure that has one element for each line in the file. The first     character of the file specifies the type: a for string, b for boolean,     i or n for integer, and d for double. # is a comment character.   ");
  
  

libdata[libdataItem++] = new Array("astro/redshift_axis.html", "redshift_axis.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "redshift_axis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/redshift_axis.html#redshift_axis", "redshift_axis", "routine in <a href="astro/redshift_axis.html">redshift_axis.pro</a>", "redshift_axis.pro", "", "redshift_axis", "    For a plotting coordinate system that is set up in terms of     cosmic time in Gyr, adds a redshift axis.   ", "xaxis       XAXIS=0 for a lower x-axis, XAXIS=1 for an upper x-axis.  yaxis       YAXIS=0 for a left y-axis, YAXIS=1, for a right y-axis.  h100        Hubble parameter in units of 100 km/s/Mpc. Required.   omegam      Total matter density at z=0. Required.   omegalambda Total vacuum energy density at z=0. Required.   lookback    Time is in lookback time (default is time since Big Bang).   _extra      Extra keywords are passed to AXIS procedure.   z      Array of redshifts at which to label axis.   ", "Astro", "    Written by Jeremy Bailin   29 May 2013       FIXME     Displays an axis showing redshift.   ");
  
  

libdata[libdataItem++] = new Array("plot/restore_plotsysvars.html", "restore_plotsysvars.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "restore_plotsysvars.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/restore_plotsysvars.html#restore_plotsysvars", "restore_plotsysvars", "routine in <a href="plot/restore_plotsysvars.html">restore_plotsysvars.pro</a>", "restore_plotsysvars.pro", "", "restore_plotsysvars", "    Restore important plotting system variables that were saved     using SAVE_PLOTSYSVARS.   ", "", "Plot", "    Written by:   Jeremy Bailin     27 Nov 2008   Released in JBIU.   ");
  
  

libdata[libdataItem++] = new Array("plot/rgbindex.html", "rgbindex.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "rgbindex.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/rgbindex.html#rgbindex", "rgbindex", "routine in <a href="plot/rgbindex.html">rgbindex.pro</a>", "rgbindex.pro", "", "rgbindex", "    Translates RGB triplets into colour indices for 24-bit decomposed mode.   ", "r  A byte or array of bytes of red values.   g  A byte or array of bytes of green values.   b  A byte or array of bytes of blue values.   ", "Plot", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU      r = [0,128,255]     g = [128,128,128]     b = [255,128,0]     colourarray = RGBINDEX(r, g, b)     Returns the colour index or indices for 24-bit decomposed mode     (DEVICE, DECOMPOSED=1) corresponding to the R,G,B triplets.   ");
  
  

libdata[libdataItem++] = new Array("math/rms.html", "rms.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "rms.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/rms.html#rms", "rms", "routine in <a href="math/rms.html">rms.pro</a>", "rms.pro", "", "rms", "    Calculates the root-mean-square of a set of values. Extra parameters such     as DIMENSION are passed through to MEAN.   ", "_extraX Array of values.   ", "Math", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU     27 May 2015   Added _EXTRA to mean call      x = 4. * RANDOMN(seed, 10000)     rmsx = RMS(x)     Calculates the square root of the mean of the squares of X.   ");
  
  

libdata[libdataItem++] = new Array("plot/save_plotsysvars.html", "save_plotsysvars.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "save_plotsysvars.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/save_plotsysvars.html#save_plotsysvars", "save_plotsysvars", "routine in <a href="plot/save_plotsysvars.html">save_plotsysvars.pro</a>", "save_plotsysvars.pro", "", "save_plotsysvars", "    Save important plotting system variables so that they can be     restored later using RESTORE_PLOTSYSVARS.   ", "", "Plot", "    Written by:   Jeremy Bailin     27 Nov 2008   Released in JBIU.   ");
  
  

libdata[libdataItem++] = new Array("math/sech.html", "sech.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "sech.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/sech.html#sech", "sech", "routine in <a href="math/sech.html">sech.pro</a>", "sech.pro", "", "sech", "    Calculates the hyperbolic inverse cosine function (sech).   ", "x  Argument to sech (may be an array).   ", "Math", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU      IDL> PRINT, SECH(1.)          0.648054     1 / cosh(X)   ");
  
  

libdata[libdataItem++] = new Array("astro/shape_iterative.html", "shape_iterative.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "shape_iterative.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/shape_iterative.html#shape_iterative", "shape_iterative", "routine in <a href="astro/shape_iterative.html">shape_iterative.pro</a>", "shape_iterative.pro", "", "shape_iterative", "      Given a 3-dimensional distribution of points, determines the best       ellipsoidal shape using particles in an interatively-defined ellipsoid       (or ellipsoidal shell) of the same shape.   ", "masses An N-element vector of the mass of each point. If not                specified, all masses are assumed to be unity.   r2weight If /R2WEIGHT is specified then particles are downweighted                  by a factor of 1/r^2 so that all particles have equal                  effect regardless of radius.   shell  Use an ellipsoidal shell rather than a filled ellipsoid. The                value is the width of the shell.   axes   An output 3x3 array containing the principal axes.                AXES[*,i] is the direction of the i-th principal axis.   fval     Iterate until the axis ratios and directions of the axes                  vary by less than FVAL. Default is 0.001.   maxit    Maximum number of iterations to allow. Default is 20.   verbose  Print information about each iteration.   pos      An Nx3 array specifying the 3d positions of the N particles                  that make up the mass distribution.   radius   Radius at which to compute the shape. For a filled ellipsoid,                  this is the geometric mean radius of the principal axes that                  define the outer limits of the ellipsoid; for an ellipsoidal shell,                  this is the geometric mean radius at the center of the shell.   ", "Astro", "      Written by:    Jeremy Bailin       22 July 2011   Initial release        Set up a 1/r^2 ellipsoidal density distribution and find its shape.        np = 100000       r = 200 * randomu(seed, np)       ph = 2. * !pi * randomu(seed, np)       th = acos(randomu(seed, np))       x = 2. * r * cos(ph) * sin(th)       y = r * sin(ph) * sin(th)       z = 3. * r * cos(th)       print, shape_iterative([[x],[y],[z]], 100., axes=axes)       print, axes       The function returns a 3-element array containing the lengths of the       principal axes of the ellipse.   ");
  
  

libdata[libdataItem++] = new Array("misc/shrinkinttype.html", "shrinkinttype.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "shrinkinttype.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/shrinkinttype.html#shrinkinttype", "shrinkinttype", "routine in <a href="misc/shrinkinttype.html">shrinkinttype.pro</a>", "shrinkinttype.pro", "", "shrinkinttype", "    Reduces the memory occupied by an integer-type array if possible by     shrinking it into a byte or unsigned short int.   ", "array  Array to be shrunk. Usually of type long. Must not be negative.   ", "Misc", "    Written by:   Jeremy Bailin     6 Dec 2012    First release      IDL> q = lindgen(300)     IDL> help, q     Q               LONG      = Array[300]     IDL> shrinkinttype, q     IDL> help, q     Q               UINT      = Array[300] ");
  
  

libdata[libdataItem++] = new Array("math/sign.html", "sign.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "sign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/sign.html#sign", "sign", "routine in <a href="math/sign.html">sign.pro</a>", "sign.pro", "", "sign", "    Returns the sign of the argument.   ", "x Numerical argument (may be an array).   ", "Math", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU     13 June 2008  Re-written to omit FOR loop (thanks to Brian                   Larsen for the suggestion).      IDL> PRINT, SIGN([-10,0,25])           -1       0       1     Returns 1 where X is positive, 0 where X is zero, and -1 where     X is negative.   ");
  
  

libdata[libdataItem++] = new Array("astro/sixtyv.html", "sixtyv.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "sixtyv.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/sixtyv.html#sixtyv", "sixtyv", "routine in <a href="astro/sixtyv.html">sixtyv.pro</a>", "sixtyv.pro", "", "sixtyv", "    Converts a vector of decimal numbers to sexigesimal (vector version of     SIXTY in the astronomy library).   ", "x   One or more decimal values, in degrees or hours.   ", "Astro", "    Written by Jeremy Bailin   20 April 2011     Based on SIXTY in the Astronomy Users Library       IDL> print, sixtyv([90., -45.5])           90.0000      0.00000      0.00000          -45.0000      30.0000      0.00000     If X is a scalar, then Result is a 3-element vector of degrees, minutes and seconds.     If X is an array of length N, then result is a 3xN array.   ");
  
  

libdata[libdataItem++] = new Array("astro/sky2xy.html", "sky2xy.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "sky2xy.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/sky2xy.html#sky2xy", "sky2xy", "routine in <a href="astro/sky2xy.html">sky2xy.pro</a>", "sky2xy.pro", "", "sky2xy", "    Converts between sky coordinates and pixel coordinates of a FITS image     using the WCSTOOLS sky2xy routine. Useful for images with WCS keywords     that are not implemented in the astronomy library (such as the TNX     convention for distortions).   ", "string  If set, Ra and Dec are strings in HH:MM:SS, DD:MM:SS format.   wcstoolsdir Path to the location of the binary sky2xy files in wcstools.   fitsfile  Name of FITS file that contains the WCS to use.   ra  Vector of right ascensions. Assumed to be in decimal degrees unless           /STRING is set.   dec Vector of declinations. Assumed to be in decimal degrees unless           /STRING is set.   ", "Astro", "    Written by:    Jeremy Bailin     20 August 2010   Initial release     10 Feb 2011    Made WCSTOOLSDIR a keyword parameter.       The function returns a structure with fields .X and .Y which are arrays     containing the x and y pixel values.   NOTES:     Requires WCSTOOLS to be installed, along with the UWashington TMPFILE     and DIR_EXIST routines.   ");
  
  

libdata[libdataItem++] = new Array("io/sort_rows.html", "sort_rows.pro", ".pro file in <a href="io/dir-overview.html">io/ directory</a>", "sort_rows.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("io/sort_rows.html#sort_rows", "sort_rows", "routine in <a href="io/sort_rows.html">sort_rows.pro</a>", "sort_rows.pro", "", "sort_rows", "    This function re-sorts the rows in a CSV structure (as read     using READ_CSV).   ", "order  A vector of indices of the new sorted order. Must have the             same elements as there are rows in A.   a  A CSV structure, of the format read in using READ_CSV.   ", "I/O", "    Written by:   Jeremy Bailin     5 Feb 2010:  Public release in JBIU      A is returned in the new sort order.   ");
  
  

libdata[libdataItem++] = new Array("plot/splineplot.html", "splineplot.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "splineplot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/splineplot.html#splineplot", "splineplot", "routine in <a href="plot/splineplot.html">splineplot.pro</a>", "splineplot.pro", "", "splineplot", "    Plots a 2D spline curve using a set of given coordinates.   ", "nspline Number of points to use to draw the curve. Default: 100.   overplotPlots over existing plot.   window  Uses the /WINDOW flag for Coyote Graphics.   addcmd  Uses the /ADDCMD flag for Coyote Graphics.   _extraxcoords   Array of x coordinates of curve.   ycoords   Array of y coordinates of curve.   ", "Plot", "    Written by:   Jeremy Bailin, 3 Dec 2010     11 March 2011 Moved to SPLINEPLOT and allowing overplot as an option.                   Switched to Coyote Graphics.       This uses GETPTS to select a number of points, and then draws a smooth curve     connecting those points:      GETPTS, x, y     SPLINEPLOT, x, y, /OVERPLOT ");
  
  

libdata[libdataItem++] = new Array("math/sprsadd.html", "sprsadd.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "sprsadd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/sprsadd.html#sprsadd", "sprsadd", "routine in <a href="math/sprsadd.html">sprsadd.pro</a>", "sprsadd.pro", "", "sprsadd", "    Adds two sparse matrices (as generated by SPRSIN).   ", "a  Sparse matrix to be added.  b  Sparse matrix to be added.   ", "Math", "    Written by:   Jeremy Bailin, November 2008       IDL> a = sprsin([[1,0,0],[0,1,0],[0,0,1]])     IDL> b = sprsin([[0,0,2],[0,2,0],[2,0,0]])     IDL> c = sprsadd(a,b)     IDL> print, fulstr(c)           1.00000      0.00000      2.00000           0.00000      3.00000      0.00000           2.00000      0.00000      1.00000     The addition of the matrices, in sparse format. This is functionally     equivalent to:       SPRSIN(FULSTR(A) + FULSTR(B))     but can be used even when the full matrices take up too much memory     for that operation.   ");
  
  

libdata[libdataItem++] = new Array("math/tanh.html", "tanh.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "tanh.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/tanh.html#tanh", "tanh", "routine in <a href="math/tanh.html">tanh.pro</a>", "tanh.pro", "", "tanh", "    Calculates the hyperbolic tan function (tanh).   ", "x  Argument to tanh (may be an array).   ", "Math", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU      IDL> PRINT, TANH(1.)          0.761594     sinh(X) / cosh(X)   ");
  
  

libdata[libdataItem++] = new Array("plot/trueify.html", "trueify.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "trueify.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/trueify.html#trueify", "trueify", "routine in <a href="plot/trueify.html">trueify.pro</a>", "trueify.pro", "", "trueify", "    Turn an indexed image into an RGB-decomposed image based on the     current colour table.   ", "image A 2d byte array image.   ", "Plot", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU      image = TVRD()     decompimage = TRUEIFY(image)     WRITE_PNG, 'image.png', decompimage     An RGB-decomposed version of Image based on the current colour     table. If Image is MxN, Result is 3xMxN.   ");
  
  

libdata[libdataItem++] = new Array("misc/uniqify.html", "uniqify.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "uniqify.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/uniqify.html#uniqify", "uniqify", "routine in <a href="misc/uniqify.html">uniqify.pro</a>", "uniqify.pro", "", "uniqify", "    Returns the unique elements of an array.   ", "array An array whose elements are to be uniqued.   ", "Misc", "    Written by:  Jeremy Bailin     9 March 2011   Initial writing   ");
  
  

libdata[libdataItem++] = new Array("misc/vecrep.html", "vecrep.pro", ".pro file in <a href="misc/dir-overview.html">misc/ directory</a>", "vecrep.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/vecrep.html#vecrep", "vecrep", "routine in <a href="misc/vecrep.html">vecrep.pro</a>", "vecrep.pro", "", "vecrep", "    Replicates a vector a given number of times.   ", "vec          1D vector to replicate   n            Number of times to replicate   ", "Misc", "    IDL> a = [10,11,12]     IDL> print, VECREP(a,2)           10      11      12      10      11      12 ");
  
  

libdata[libdataItem++] = new Array("astro/velframe.html", "velframe.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "velframe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/velframe.html#velframe", "velframe", "routine in <a href="astro/velframe.html">velframe.pro</a>", "velframe.pro", "", "velframe", "    Converts radial velocities between Local Standard of Rest, Heliocentric and Galactocentric velocity frames.   ", "galacticIf set, input coordinates are in decimal galactic coordinates (l,b) rather than RA and Dec.   vlsrvheliovgsrinframe Input frame. One of 'LSR', 'HELIO' or 'GSR'.   outframeOutput frame. One of 'LSR', 'HELIO' or 'GSR'.   equinox Equinox year of Coords. Default: 2000.0.   velocity   Scalar or vector of radial velocity to be converted, in km/s.   longitude  Scalar or vector of longitudinal coordinates at which the transformation is computed.                  Assumed to be decimal RA degrees unless /GALACTIC is specified, in which case it is                  decimal galactic l.   latitude   Scalar or vector of latitudinal coordinates at which the transformation is computed.                  Assumed to be decimal Dec degrees unless /GALACTIC is specified, in which case it is                  decimal galactic b.   ", "Astro", "    Written by:   Jeremy Bailin     29 July 2016  Initial writing      Output radial velocity in desired frame, assuming no proper motion.   ");
  
  

libdata[libdataItem++] = new Array("plot/xladder.html", "xladder.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "xladder.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/xladder.html#xladder", "xladder", "routine in <a href="plot/xladder.html">xladder.pro</a>", "xladder.pro", "", "xladder", "    Creates horizontally-stacked ladder plots.   ", "xrange  The x-range of the plots in normalized units. Default: [0.1,0.9]   yrange  The y-range of the plots in normalized units. Default: [0.1,0.9]   _extranx  Number of plots.   ", "Plot", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU     13 June 2011   Changed to be a wrapper to XYLADDER.      ladderpos = XLADDER(2)     PLOT, x1, y1, POS=ladderpos[*,0]     PLOT, x2, y2, /NOERASE, YTICKFORMAT='(A1)', POS=ladderpos[*,1]     A 4xNX array containing the normalized position coordinates for each     plot. Result[*,N] are the normalized coordinates for plot N (going     from left to right).   ");
  
  

libdata[libdataItem++] = new Array("astro/xy2sky.html", "xy2sky.pro", ".pro file in <a href="astro/dir-overview.html">astro/ directory</a>", "xy2sky.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("astro/xy2sky.html#xy2sky", "xy2sky", "routine in <a href="astro/xy2sky.html">xy2sky.pro</a>", "xy2sky.pro", "", "xy2sky", "    Converts between pixel coordinates of a FITS image and sky coordinates     using the WCSTOOLS xy2sky routine. Useful for images with WCS keywords     that are not implemented in the astronomy library (such as the TNX     convention for distortions).   ", "string   Output strings of HH:MM:SS and DD:MM:SS format.   wcstoolsdir  Path to the location of the binary xy2sky in wcstools.   fitsfile  Name of FITS file that contains the WCS to use.   x         Vector of x coordinates.   y         Vector of y coordinates.   ", "Astro", "    Written by:    Jeremy Bailin     20 August 2010   Initial release     10 Feb 2011    Made WCSTOOLSDIR a keyword parameter.       The function returns a structure with fields .RA and .DEC which are arrays     containing the RA and Dec values in decimal degrees (or in strings,     if /STRING is set).   NOTES:     Requires WCSTOOLS to be installed, along with the UWashington TMPFILE     and DIR_EXIST routines.   ");
  
  

libdata[libdataItem++] = new Array("plot/xyladder.html", "xyladder.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "xyladder.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/xyladder.html#xyladder", "xyladder", "routine in <a href="plot/xyladder.html">xyladder.pro</a>", "xyladder.pro", "", "xyladder", "    Creates horizontally- and vertically-stacked ladder plots.   ", "xrange  The x-range of the plots in normalized units. Default: [0.1,0.9]   yrange  The y-range of the plots in normalized units. Default: [0.1,0.9]   isotropicIf set, each panel is a square.   nx  Number of plots in the horizontal direction.   ny  Number of plots in the vertical direction.   ", "Plot", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU     13 June 2011   Added /ISTROPIC keyword      ladderpos = XYLADDER(2,2)     PLOT, x1, y1, POS=ladderpos[*,0,0]     PLOT, x2, y2, /NOERASE, YTICKFORMAT='(A1)', POS=ladderpos[*,1,0]     PLOT, x3, y3, /NOERASE, XTICKFORMAT='(A1)', POS=ladderpos[*,0,1]     PLOT, x4, y4, /NOERASE, XTICKFORMAT='(A1)', YTICKFORMAT='(A1)',        POS=ladderpos[*,1,1]     A 4xNXxNY array containing the normalized position coordinates for each     plot. Result[*,IX,IY] are the normalized coordinates for horizontal     plot IX (from left to right) and vertical plot IY (from bottom to top).   ");
  
  

libdata[libdataItem++] = new Array("plot/yladder.html", "yladder.pro", ".pro file in <a href="plot/dir-overview.html">plot/ directory</a>", "yladder.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("plot/yladder.html#yladder", "yladder", "routine in <a href="plot/yladder.html">yladder.pro</a>", "yladder.pro", "", "yladder", "    Creates vertically-stacked ladder plots.   ", "xrange  The x-range of the plots in normalized units. Default: [0.1,0.9]   yrange  The y-range of the plots in normalized units. Default: [0.1,0.9]   _extrany  Number of plots.   ", "Plot", "    Written by:    Jeremy Bailin     12 June 2008   Public release in JBIU     13 June 2011   Changed to be a wrapper to XYLADDER     24 June 2011   Bug fix related to above change.      ladderpos = YLADDER(2)     PLOT, x1, y1, POS=ladderpos[*,0]     PLOT, x2, y2, /NOERASE, YTICKFORMAT='(A1)', POS=ladderpos[*,1]     A 4xNY array containing the normalized position coordinates for each     plot. Result[*,N] are the normalized coordinates for plot N (going     from bottom to top).   ");
  
  

libdata[libdataItem++] = new Array("math/zphase.html", "zphase.pro", ".pro file in <a href="math/dir-overview.html">math/ directory</a>", "zphase.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("math/zphase.html#zphase", "zphase", "routine in <a href="math/zphase.html">zphase.pro</a>", "zphase.pro", "", "zphase", "    Calculates the phase angle of a complex number.   ", "z   Complex number or array.   ", "Math", "    Written by:   Jeremy Bailin     12 June 2008  Public release in JBIU      z = COMPLEX(1,1)     arg = ZPHASE(Z)     Result is the phase of the complex number(s) Z. Ie. if Z = A e(i phi)     then phi=ZPHASE(Z).   ");
  
  

